"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@pdf-lib+upng@1.0.1";
exports.ids = ["vendor-chunks/@pdf-lib+upng@1.0.1"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@pdf-lib+upng@1.0.1/node_modules/@pdf-lib/upng/UPNG.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/.pnpm/@pdf-lib+upng@1.0.1/node_modules/@pdf-lib/upng/UPNG.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var pako__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pako */ \"(ssr)/./node_modules/.pnpm/pako@1.0.11/node_modules/pako/index.js\");\n/* harmony import */ var pako__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(pako__WEBPACK_IMPORTED_MODULE_0__);\n\n\nvar UPNG = {};\n\n\t\n\nUPNG.toRGBA8 = function(out)\n{\n\tvar w = out.width, h = out.height;\n\tif(out.tabs.acTL==null) return [UPNG.toRGBA8.decodeImage(out.data, w, h, out).buffer];\n\t\n\tvar frms = [];\n\tif(out.frames[0].data==null) out.frames[0].data = out.data;\n\t\n\tvar len = w*h*4, img = new Uint8Array(len), empty = new Uint8Array(len), prev=new Uint8Array(len);\n\tfor(var i=0; i<out.frames.length; i++)\n\t{\n\t\tvar frm = out.frames[i];\n\t\tvar fx=frm.rect.x, fy=frm.rect.y, fw = frm.rect.width, fh = frm.rect.height;\n\t\tvar fdata = UPNG.toRGBA8.decodeImage(frm.data, fw,fh, out);\n\t\t\n\t\tif(i!=0) for(var j=0; j<len; j++) prev[j]=img[j];\n\t\t\n\t\tif     (frm.blend==0) UPNG._copyTile(fdata, fw, fh, img, w, h, fx, fy, 0);\n\t\telse if(frm.blend==1) UPNG._copyTile(fdata, fw, fh, img, w, h, fx, fy, 1);\n\t\t\n\t\tfrms.push(img.buffer.slice(0));\n\t\t\n\t\tif     (frm.dispose==0) {}\n\t\telse if(frm.dispose==1) UPNG._copyTile(empty, fw, fh, img, w, h, fx, fy, 0);\n\t\telse if(frm.dispose==2) for(var j=0; j<len; j++) img[j]=prev[j];\n\t}\n\treturn frms;\n}\nUPNG.toRGBA8.decodeImage = function(data, w, h, out)\n{\n\tvar area = w*h, bpp = UPNG.decode._getBPP(out);\n\tvar bpl = Math.ceil(w*bpp/8);\t// bytes per line\n\n\tvar bf = new Uint8Array(area*4), bf32 = new Uint32Array(bf.buffer);\n\tvar ctype = out.ctype, depth = out.depth;\n\tvar rs = UPNG._bin.readUshort;\n\t\n\t//console.log(ctype, depth);\n\tvar time = Date.now();\n\n\tif     (ctype==6) { // RGB + alpha\n\t\tvar qarea = area<<2;\n\t\tif(depth== 8) for(var i=0; i<qarea;i+=4) {  bf[i] = data[i];  bf[i+1] = data[i+1];  bf[i+2] = data[i+2];  bf[i+3] = data[i+3]; }\n\t\tif(depth==16) for(var i=0; i<qarea;i++ ) {  bf[i] = data[i<<1];  }\n\t}\n\telse if(ctype==2) {\t// RGB\n\t\tvar ts=out.tabs[\"tRNS\"];\n\t\tif(ts==null) {\n\t\t\tif(depth== 8) for(var i=0; i<area; i++) {  var ti=i*3;  bf32[i] = (255<<24)|(data[ti+2]<<16)|(data[ti+1]<<8)|data[ti];  }\n\t\t\tif(depth==16) for(var i=0; i<area; i++) {  var ti=i*6;  bf32[i] = (255<<24)|(data[ti+4]<<16)|(data[ti+2]<<8)|data[ti];  }\n\t\t}\n\t\telse {  var tr=ts[0], tg=ts[1], tb=ts[2];\n\t\t\tif(depth== 8) for(var i=0; i<area; i++) {  var qi=i<<2, ti=i*3;  bf32[i] = (255<<24)|(data[ti+2]<<16)|(data[ti+1]<<8)|data[ti];\n\t\t\t\tif(data[ti]   ==tr && data[ti+1]   ==tg && data[ti+2]   ==tb) bf[qi+3] = 0;  }\n\t\t\tif(depth==16) for(var i=0; i<area; i++) {  var qi=i<<2, ti=i*6;  bf32[i] = (255<<24)|(data[ti+4]<<16)|(data[ti+2]<<8)|data[ti];\n\t\t\t\tif(rs(data,ti)==tr && rs(data,ti+2)==tg && rs(data,ti+4)==tb) bf[qi+3] = 0;  }\n\t\t}\n\t}\n\telse if(ctype==3) {\t// palette\n\t\tvar p=out.tabs[\"PLTE\"], ap=out.tabs[\"tRNS\"], tl=ap?ap.length:0;\n\t\t//console.log(p, ap);\n\t\tif(depth==1) for(var y=0; y<h; y++) {  var s0 = y*bpl, t0 = y*w;\n\t\t\tfor(var i=0; i<w; i++) { var qi=(t0+i)<<2, j=((data[s0+(i>>3)]>>(7-((i&7)<<0)))& 1), cj=3*j;  bf[qi]=p[cj];  bf[qi+1]=p[cj+1];  bf[qi+2]=p[cj+2];  bf[qi+3]=(j<tl)?ap[j]:255;  }\n\t\t}\n\t\tif(depth==2) for(var y=0; y<h; y++) {  var s0 = y*bpl, t0 = y*w;\n\t\t\tfor(var i=0; i<w; i++) { var qi=(t0+i)<<2, j=((data[s0+(i>>2)]>>(6-((i&3)<<1)))& 3), cj=3*j;  bf[qi]=p[cj];  bf[qi+1]=p[cj+1];  bf[qi+2]=p[cj+2];  bf[qi+3]=(j<tl)?ap[j]:255;  }\n\t\t}\n\t\tif(depth==4) for(var y=0; y<h; y++) {  var s0 = y*bpl, t0 = y*w;\n\t\t\tfor(var i=0; i<w; i++) { var qi=(t0+i)<<2, j=((data[s0+(i>>1)]>>(4-((i&1)<<2)))&15), cj=3*j;  bf[qi]=p[cj];  bf[qi+1]=p[cj+1];  bf[qi+2]=p[cj+2];  bf[qi+3]=(j<tl)?ap[j]:255;  }\n\t\t}\n\t\tif(depth==8) for(var i=0; i<area; i++ ) {  var qi=i<<2, j=data[i]                      , cj=3*j;  bf[qi]=p[cj];  bf[qi+1]=p[cj+1];  bf[qi+2]=p[cj+2];  bf[qi+3]=(j<tl)?ap[j]:255;  }\n\t}\n\telse if(ctype==4) {\t// gray + alpha\n\t\tif(depth== 8)  for(var i=0; i<area; i++) {  var qi=i<<2, di=i<<1, gr=data[di];  bf[qi]=gr;  bf[qi+1]=gr;  bf[qi+2]=gr;  bf[qi+3]=data[di+1];  }\n\t\tif(depth==16)  for(var i=0; i<area; i++) {  var qi=i<<2, di=i<<2, gr=data[di];  bf[qi]=gr;  bf[qi+1]=gr;  bf[qi+2]=gr;  bf[qi+3]=data[di+2];  }\n\t}\n\telse if(ctype==0) {\t// gray\n\t\tvar tr = out.tabs[\"tRNS\"] ? out.tabs[\"tRNS\"] : -1;\n\t\tfor(var y=0; y<h; y++) {\n\t\t\tvar off = y*bpl, to = y*w;\n\t\t\tif     (depth== 1) for(var x=0; x<w; x++) {  var gr=255*((data[off+(x>>>3)]>>>(7 -((x&7)   )))& 1), al=(gr==tr*255)?0:255;  bf32[to+x]=(al<<24)|(gr<<16)|(gr<<8)|gr;  }\n\t\t\telse if(depth== 2) for(var x=0; x<w; x++) {  var gr= 85*((data[off+(x>>>2)]>>>(6 -((x&3)<<1)))& 3), al=(gr==tr* 85)?0:255;  bf32[to+x]=(al<<24)|(gr<<16)|(gr<<8)|gr;  }\n\t\t\telse if(depth== 4) for(var x=0; x<w; x++) {  var gr= 17*((data[off+(x>>>1)]>>>(4 -((x&1)<<2)))&15), al=(gr==tr* 17)?0:255;  bf32[to+x]=(al<<24)|(gr<<16)|(gr<<8)|gr;  }\n\t\t\telse if(depth== 8) for(var x=0; x<w; x++) {  var gr=data[off+     x], al=(gr                 ==tr)?0:255;  bf32[to+x]=(al<<24)|(gr<<16)|(gr<<8)|gr;  }\n\t\t\telse if(depth==16) for(var x=0; x<w; x++) {  var gr=data[off+(x<<1)], al=(rs(data,off+(x<<i))==tr)?0:255;  bf32[to+x]=(al<<24)|(gr<<16)|(gr<<8)|gr;  }\n\t\t}\n\t}\n\t//console.log(Date.now()-time);\n\treturn bf;\n}\n\n\n\nUPNG.decode = function(buff)\n{\n\tvar data = new Uint8Array(buff), offset = 8, bin = UPNG._bin, rUs = bin.readUshort, rUi = bin.readUint;\n\tvar out = {tabs:{}, frames:[]};\n\tvar dd = new Uint8Array(data.length), doff = 0;\t // put all IDAT data into it\n\tvar fd, foff = 0;\t// frames\n\t\n\tvar mgck = [0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a];\n\tfor(var i=0; i<8; i++) if(data[i]!=mgck[i]) throw \"The input is not a PNG file!\";\n\n\twhile(offset<data.length)\n\t{\n\t\tvar len  = bin.readUint(data, offset);  offset += 4;\n\t\tvar type = bin.readASCII(data, offset, 4);  offset += 4;\n\t\t//console.log(type,len);\n\t\t\n\t\tif     (type==\"IHDR\")  {  UPNG.decode._IHDR(data, offset, out);  }\n\t\telse if(type==\"IDAT\") {\n\t\t\tfor(var i=0; i<len; i++) dd[doff+i] = data[offset+i];\n\t\t\tdoff += len;\n\t\t}\n\t\telse if(type==\"acTL\")  {\n\t\t\tout.tabs[type] = {  num_frames:rUi(data, offset), num_plays:rUi(data, offset+4)  };\n\t\t\tfd = new Uint8Array(data.length);\n\t\t}\n\t\telse if(type==\"fcTL\")  {\n\t\t\tif(foff!=0) {  var fr = out.frames[out.frames.length-1];\n\t\t\t\tfr.data = UPNG.decode._decompress(out, fd.slice(0,foff), fr.rect.width, fr.rect.height);  foff=0;\n\t\t\t}\n\t\t\tvar rct = {x:rUi(data, offset+12),y:rUi(data, offset+16),width:rUi(data, offset+4),height:rUi(data, offset+8)};\n\t\t\tvar del = rUs(data, offset+22);  del = rUs(data, offset+20) / (del==0?100:del);\n\t\t\tvar frm = {rect:rct, delay:Math.round(del*1000), dispose:data[offset+24], blend:data[offset+25]};\n\t\t\t//console.log(frm);\n\t\t\tout.frames.push(frm);\n\t\t}\n\t\telse if(type==\"fdAT\") {\n\t\t\tfor(var i=0; i<len-4; i++) fd[foff+i] = data[offset+i+4];\n\t\t\tfoff += len-4;\n\t\t}\n\t\telse if(type==\"pHYs\") {\n\t\t\tout.tabs[type] = [bin.readUint(data, offset), bin.readUint(data, offset+4), data[offset+8]];\n\t\t}\n\t\telse if(type==\"cHRM\") {\n\t\t\tout.tabs[type] = [];\n\t\t\tfor(var i=0; i<8; i++) out.tabs[type].push(bin.readUint(data, offset+i*4));\n\t\t}\n\t\telse if(type==\"tEXt\") {\n\t\t\tif(out.tabs[type]==null) out.tabs[type] = {};\n\t\t\tvar nz = bin.nextZero(data, offset);\n\t\t\tvar keyw = bin.readASCII(data, offset, nz-offset);\n\t\t\tvar text = bin.readASCII(data, nz+1, offset+len-nz-1);\n\t\t\tout.tabs[type][keyw] = text;\n\t\t}\n\t\telse if(type==\"iTXt\") {\n\t\t\tif(out.tabs[type]==null) out.tabs[type] = {};\n\t\t\tvar nz = 0, off = offset;\n\t\t\tnz = bin.nextZero(data, off);\n\t\t\tvar keyw = bin.readASCII(data, off, nz-off);  off = nz + 1;\n\t\t\tvar cflag = data[off], cmeth = data[off+1];  off+=2;\n\t\t\tnz = bin.nextZero(data, off);\n\t\t\tvar ltag = bin.readASCII(data, off, nz-off);  off = nz + 1;\n\t\t\tnz = bin.nextZero(data, off);\n\t\t\tvar tkeyw = bin.readUTF8(data, off, nz-off);  off = nz + 1;\n\t\t\tvar text  = bin.readUTF8(data, off, len-(off-offset));\n\t\t\tout.tabs[type][keyw] = text;\n\t\t}\n\t\telse if(type==\"PLTE\") {\n\t\t\tout.tabs[type] = bin.readBytes(data, offset, len);\n\t\t}\n\t\telse if(type==\"hIST\") {\n\t\t\tvar pl = out.tabs[\"PLTE\"].length/3;\n\t\t\tout.tabs[type] = [];  for(var i=0; i<pl; i++) out.tabs[type].push(rUs(data, offset+i*2));\n\t\t}\n\t\telse if(type==\"tRNS\") {\n\t\t\tif     (out.ctype==3) out.tabs[type] = bin.readBytes(data, offset, len);\n\t\t\telse if(out.ctype==0) out.tabs[type] = rUs(data, offset);\n\t\t\telse if(out.ctype==2) out.tabs[type] = [ rUs(data,offset),rUs(data,offset+2),rUs(data,offset+4) ];\n\t\t\t//else console.log(\"tRNS for unsupported color type\",out.ctype, len);\n\t\t}\n\t\telse if(type==\"gAMA\") out.tabs[type] = bin.readUint(data, offset)/100000;\n\t\telse if(type==\"sRGB\") out.tabs[type] = data[offset];\n\t\telse if(type==\"bKGD\")\n\t\t{\n\t\t\tif     (out.ctype==0 || out.ctype==4) out.tabs[type] = [rUs(data, offset)];\n\t\t\telse if(out.ctype==2 || out.ctype==6) out.tabs[type] = [rUs(data, offset), rUs(data, offset+2), rUs(data, offset+4)];\n\t\t\telse if(out.ctype==3) out.tabs[type] = data[offset];\n\t\t}\n\t\telse if(type==\"IEND\") {\n\t\t\tbreak;\n\t\t}\n\t\t//else {  log(\"unknown chunk type\", type, len);  }\n\t\toffset += len;\n\t\tvar crc = bin.readUint(data, offset);  offset += 4;\n\t}\n\tif(foff!=0) {  var fr = out.frames[out.frames.length-1];\n\t\tfr.data = UPNG.decode._decompress(out, fd.slice(0,foff), fr.rect.width, fr.rect.height);  foff=0;\n\t}\t\n\tout.data = UPNG.decode._decompress(out, dd, out.width, out.height);\n\t\n\tdelete out.compress;  delete out.interlace;  delete out.filter;\n\treturn out;\n}\n\nUPNG.decode._decompress = function(out, dd, w, h) {\n\tvar time = Date.now();\n\tvar bpp = UPNG.decode._getBPP(out), bpl = Math.ceil(w*bpp/8), buff = new Uint8Array((bpl+1+out.interlace)*h);\n\tdd = UPNG.decode._inflate(dd,buff);\n\t//console.log(dd.length, buff.length);\n\t//console.log(Date.now()-time);\n\n\tvar time=Date.now();\n\tif     (out.interlace==0) dd = UPNG.decode._filterZero(dd, out, 0, w, h);\n\telse if(out.interlace==1) dd = UPNG.decode._readInterlace(dd, out);\n\t//console.log(Date.now()-time);\n\treturn dd;\n}\n\nUPNG.decode._inflate = function(data, buff) {  var out=UPNG[\"inflateRaw\"](new Uint8Array(data.buffer, 2,data.length-6),buff);  return out;  }\nUPNG.inflateRaw=function(){var H={};H.H={};H.H.N=function(N,W){var R=Uint8Array,i=0,m=0,J=0,h=0,Q=0,X=0,u=0,w=0,d=0,v,C;\nif(N[0]==3&&N[1]==0)return W?W:new R(0);var V=H.H,n=V.b,A=V.e,l=V.R,M=V.n,I=V.A,e=V.Z,b=V.m,Z=W==null;\nif(Z)W=new R(N.length>>>2<<3);while(i==0){i=n(N,d,1);m=n(N,d+1,2);d+=3;if(m==0){if((d&7)!=0)d+=8-(d&7);\nvar D=(d>>>3)+4,q=N[D-4]|N[D-3]<<8;if(Z)W=H.H.W(W,w+q);W.set(new R(N.buffer,N.byteOffset+D,q),w);d=D+q<<3;\nw+=q;continue}if(Z)W=H.H.W(W,w+(1<<17));if(m==1){v=b.J;C=b.h;X=(1<<9)-1;u=(1<<5)-1}if(m==2){J=A(N,d,5)+257;\nh=A(N,d+5,5)+1;Q=A(N,d+10,4)+4;d+=14;var E=d,j=1;for(var c=0;c<38;c+=2){b.Q[c]=0;b.Q[c+1]=0}for(var c=0;\nc<Q;c++){var K=A(N,d+c*3,3);b.Q[(b.X[c]<<1)+1]=K;if(K>j)j=K}d+=3*Q;M(b.Q,j);I(b.Q,j,b.u);v=b.w;C=b.d;\nd=l(b.u,(1<<j)-1,J+h,N,d,b.v);var r=V.V(b.v,0,J,b.C);X=(1<<r)-1;var S=V.V(b.v,J,h,b.D);u=(1<<S)-1;M(b.C,r);\nI(b.C,r,v);M(b.D,S);I(b.D,S,C)}while(!0){var T=v[e(N,d)&X];d+=T&15;var p=T>>>4;if(p>>>8==0){W[w++]=p}else if(p==256){break}else{var z=w+p-254;\nif(p>264){var _=b.q[p-257];z=w+(_>>>3)+A(N,d,_&7);d+=_&7}var $=C[e(N,d)&u];d+=$&15;var s=$>>>4,Y=b.c[s],a=(Y>>>4)+n(N,d,Y&15);\nd+=Y&15;while(w<z){W[w]=W[w++-a];W[w]=W[w++-a];W[w]=W[w++-a];W[w]=W[w++-a]}w=z}}}return W.length==w?W:W.slice(0,w)};\nH.H.W=function(N,W){var R=N.length;if(W<=R)return N;var V=new Uint8Array(R<<1);V.set(N,0);return V};\nH.H.R=function(N,W,R,V,n,A){var l=H.H.e,M=H.H.Z,I=0;while(I<R){var e=N[M(V,n)&W];n+=e&15;var b=e>>>4;\nif(b<=15){A[I]=b;I++}else{var Z=0,m=0;if(b==16){m=3+l(V,n,2);n+=2;Z=A[I-1]}else if(b==17){m=3+l(V,n,3);\nn+=3}else if(b==18){m=11+l(V,n,7);n+=7}var J=I+m;while(I<J){A[I]=Z;I++}}}return n};H.H.V=function(N,W,R,V){var n=0,A=0,l=V.length>>>1;\nwhile(A<R){var M=N[A+W];V[A<<1]=0;V[(A<<1)+1]=M;if(M>n)n=M;A++}while(A<l){V[A<<1]=0;V[(A<<1)+1]=0;A++}return n};\nH.H.n=function(N,W){var R=H.H.m,V=N.length,n,A,l,M,I,e=R.j;for(var M=0;M<=W;M++)e[M]=0;for(M=1;M<V;M+=2)e[N[M]]++;\nvar b=R.K;n=0;e[0]=0;for(A=1;A<=W;A++){n=n+e[A-1]<<1;b[A]=n}for(l=0;l<V;l+=2){I=N[l+1];if(I!=0){N[l]=b[I];\nb[I]++}}};H.H.A=function(N,W,R){var V=N.length,n=H.H.m,A=n.r;for(var l=0;l<V;l+=2)if(N[l+1]!=0){var M=l>>1,I=N[l+1],e=M<<4|I,b=W-I,Z=N[l]<<b,m=Z+(1<<b);\nwhile(Z!=m){var J=A[Z]>>>15-W;R[J]=e;Z++}}};H.H.l=function(N,W){var R=H.H.m.r,V=15-W;for(var n=0;n<N.length;\nn+=2){var A=N[n]<<W-N[n+1];N[n]=R[A]>>>V}};H.H.M=function(N,W,R){R=R<<(W&7);var V=W>>>3;N[V]|=R;N[V+1]|=R>>>8};\nH.H.I=function(N,W,R){R=R<<(W&7);var V=W>>>3;N[V]|=R;N[V+1]|=R>>>8;N[V+2]|=R>>>16};H.H.e=function(N,W,R){return(N[W>>>3]|N[(W>>>3)+1]<<8)>>>(W&7)&(1<<R)-1};\nH.H.b=function(N,W,R){return(N[W>>>3]|N[(W>>>3)+1]<<8|N[(W>>>3)+2]<<16)>>>(W&7)&(1<<R)-1};H.H.Z=function(N,W){return(N[W>>>3]|N[(W>>>3)+1]<<8|N[(W>>>3)+2]<<16)>>>(W&7)};\nH.H.i=function(N,W){return(N[W>>>3]|N[(W>>>3)+1]<<8|N[(W>>>3)+2]<<16|N[(W>>>3)+3]<<24)>>>(W&7)};H.H.m=function(){var N=Uint16Array,W=Uint32Array;\nreturn{K:new N(16),j:new N(16),X:[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],S:[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,999,999,999],T:[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0],q:new N(32),p:[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,65535,65535],z:[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0],c:new W(32),J:new N(512),_:[],h:new N(32),$:[],w:new N(32768),C:[],v:[],d:new N(32768),D:[],u:new N(512),Q:[],r:new N(1<<15),s:new W(286),Y:new W(30),a:new W(19),t:new W(15e3),k:new N(1<<16),g:new N(1<<15)}}();\n(function(){var N=H.H.m,W=1<<15;for(var R=0;R<W;R++){var V=R;V=(V&2863311530)>>>1|(V&1431655765)<<1;\nV=(V&3435973836)>>>2|(V&858993459)<<2;V=(V&4042322160)>>>4|(V&252645135)<<4;V=(V&4278255360)>>>8|(V&16711935)<<8;\nN.r[R]=(V>>>16|V<<16)>>>17}function n(A,l,M){while(l--!=0)A.push(0,M)}for(var R=0;R<32;R++){N.q[R]=N.S[R]<<3|N.T[R];\nN.c[R]=N.p[R]<<4|N.z[R]}n(N._,144,8);n(N._,255-143,9);n(N._,279-255,7);n(N._,287-279,8);H.H.n(N._,9);\nH.H.A(N._,9,N.J);H.H.l(N._,9);n(N.$,32,5);H.H.n(N.$,5);H.H.A(N.$,5,N.h);H.H.l(N.$,5);n(N.Q,19,0);n(N.C,286,0);\nn(N.D,30,0);n(N.v,320,0)}());return H.H.N}()\n\n\nUPNG.decode._readInterlace = function(data, out)\n{\n\tvar w = out.width, h = out.height;\n\tvar bpp = UPNG.decode._getBPP(out), cbpp = bpp>>3, bpl = Math.ceil(w*bpp/8);\n\tvar img = new Uint8Array( h * bpl );\n\tvar di = 0;\n\n\tvar starting_row  = [ 0, 0, 4, 0, 2, 0, 1 ];\n\tvar starting_col  = [ 0, 4, 0, 2, 0, 1, 0 ];\n\tvar row_increment = [ 8, 8, 8, 4, 4, 2, 2 ];\n\tvar col_increment = [ 8, 8, 4, 4, 2, 2, 1 ];\n\n\tvar pass=0;\n\twhile(pass<7)\n\t{\n\t\tvar ri = row_increment[pass], ci = col_increment[pass];\n\t\tvar sw = 0, sh = 0;\n\t\tvar cr = starting_row[pass];  while(cr<h) {  cr+=ri;  sh++;  }\n\t\tvar cc = starting_col[pass];  while(cc<w) {  cc+=ci;  sw++;  }\n\t\tvar bpll = Math.ceil(sw*bpp/8);\n\t\tUPNG.decode._filterZero(data, out, di, sw, sh);\n\n\t\tvar y=0, row = starting_row[pass];\n\t\twhile(row<h)\n\t\t{\n\t\t\tvar col = starting_col[pass];\n\t\t\tvar cdi = (di+y*bpll)<<3;\n\n\t\t\twhile(col<w)\n\t\t\t{\n\t\t\t\tif(bpp==1) {\n\t\t\t\t\tvar val = data[cdi>>3];  val = (val>>(7-(cdi&7)))&1;\n\t\t\t\t\timg[row*bpl + (col>>3)] |= (val << (7-((col&7)<<0)));\n\t\t\t\t}\n\t\t\t\tif(bpp==2) {\n\t\t\t\t\tvar val = data[cdi>>3];  val = (val>>(6-(cdi&7)))&3;\n\t\t\t\t\timg[row*bpl + (col>>2)] |= (val << (6-((col&3)<<1)));\n\t\t\t\t}\n\t\t\t\tif(bpp==4) {\n\t\t\t\t\tvar val = data[cdi>>3];  val = (val>>(4-(cdi&7)))&15;\n\t\t\t\t\timg[row*bpl + (col>>1)] |= (val << (4-((col&1)<<2)));\n\t\t\t\t}\n\t\t\t\tif(bpp>=8) {\n\t\t\t\t\tvar ii = row*bpl+col*cbpp;\n\t\t\t\t\tfor(var j=0; j<cbpp; j++) img[ii+j] = data[(cdi>>3)+j];\n\t\t\t\t}\n\t\t\t\tcdi+=bpp;  col+=ci;\n\t\t\t}\n\t\t\ty++;  row += ri;\n\t\t}\n\t\tif(sw*sh!=0) di += sh * (1 + bpll);\n\t\tpass = pass + 1;\n\t}\n\treturn img;\n}\n\nUPNG.decode._getBPP = function(out) {\n\tvar noc = [1,null,3,1,2,null,4][out.ctype];\n\treturn noc * out.depth;\n}\n\nUPNG.decode._filterZero = function(data, out, off, w, h)\n{\n\tvar bpp = UPNG.decode._getBPP(out), bpl = Math.ceil(w*bpp/8), paeth = UPNG.decode._paeth;\n\tbpp = Math.ceil(bpp/8);\n\t\n\tvar i=0, di=1, type=data[off], x=0;\n\t\n\tif(type>1) data[off]=[0,0,1][type-2];  \n\tif(type==3) for(x=bpp; x<bpl; x++) data[x+1] = (data[x+1] + (data[x+1-bpp]>>>1) )&255;\n\n\tfor(var y=0; y<h; y++)  {\n\t\ti = off+y*bpl; di = i+y+1;\n\t\ttype = data[di-1]; x=0;\n\n\t\tif     (type==0)   for(; x<bpl; x++) data[i+x] = data[di+x];\n\t\telse if(type==1) { for(; x<bpp; x++) data[i+x] = data[di+x];\n\t\t\t\t\t\t   for(; x<bpl; x++) data[i+x] = (data[di+x] + data[i+x-bpp]);  }\n\t\telse if(type==2) { for(; x<bpl; x++) data[i+x] = (data[di+x] + data[i+x-bpl]);  }\n\t\telse if(type==3) { for(; x<bpp; x++) data[i+x] = (data[di+x] + ( data[i+x-bpl]>>>1));\n\t\t\t               for(; x<bpl; x++) data[i+x] = (data[di+x] + ((data[i+x-bpl]+data[i+x-bpp])>>>1) );  }\n\t\telse             { for(; x<bpp; x++) data[i+x] = (data[di+x] + paeth(0, data[i+x-bpl], 0));\n\t\t\t\t\t\t   for(; x<bpl; x++) data[i+x] = (data[di+x] + paeth(data[i+x-bpp], data[i+x-bpl], data[i+x-bpp-bpl]) );  }\n\t}\n\treturn data;\n}\n\nUPNG.decode._paeth = function(a,b,c)\n{\n\tvar p = a+b-c, pa = (p-a), pb = (p-b), pc = (p-c);\n\tif (pa*pa <= pb*pb && pa*pa <= pc*pc)  return a;\n\telse if (pb*pb <= pc*pc)  return b;\n\treturn c;\n}\n\nUPNG.decode._IHDR = function(data, offset, out)\n{\n\tvar bin = UPNG._bin;\n\tout.width  = bin.readUint(data, offset);  offset += 4;\n\tout.height = bin.readUint(data, offset);  offset += 4;\n\tout.depth     = data[offset];  offset++;\n\tout.ctype     = data[offset];  offset++;\n\tout.compress  = data[offset];  offset++;\n\tout.filter    = data[offset];  offset++;\n\tout.interlace = data[offset];  offset++;\n}\n\nUPNG._bin = {\n\tnextZero   : function(data,p)  {  while(data[p]!=0) p++;  return p;  },\n\treadUshort : function(buff,p)  {  return (buff[p]<< 8) | buff[p+1];  },\n\twriteUshort: function(buff,p,n){  buff[p] = (n>>8)&255;  buff[p+1] = n&255;  },\n\treadUint   : function(buff,p)  {  return (buff[p]*(256*256*256)) + ((buff[p+1]<<16) | (buff[p+2]<< 8) | buff[p+3]);  },\n\twriteUint  : function(buff,p,n){  buff[p]=(n>>24)&255;  buff[p+1]=(n>>16)&255;  buff[p+2]=(n>>8)&255;  buff[p+3]=n&255;  },\n\treadASCII  : function(buff,p,l){  var s = \"\";  for(var i=0; i<l; i++) s += String.fromCharCode(buff[p+i]);  return s;    },\n\twriteASCII : function(data,p,s){  for(var i=0; i<s.length; i++) data[p+i] = s.charCodeAt(i);  },\n\treadBytes  : function(buff,p,l){  var arr = [];   for(var i=0; i<l; i++) arr.push(buff[p+i]);   return arr;  },\n\tpad : function(n) { return n.length < 2 ? \"0\" + n : n; },\n\treadUTF8 : function(buff, p, l) {\n\t\tvar s = \"\", ns;\n\t\tfor(var i=0; i<l; i++) s += \"%\" + UPNG._bin.pad(buff[p+i].toString(16));\n\t\ttry {  ns = decodeURIComponent(s); }\n\t\tcatch(e) {  return UPNG._bin.readASCII(buff, p, l);  }\n\t\treturn  ns;\n\t}\n}\nUPNG._copyTile = function(sb, sw, sh, tb, tw, th, xoff, yoff, mode)\n{\n\tvar w = Math.min(sw,tw), h = Math.min(sh,th);\n\tvar si=0, ti=0;\n\tfor(var y=0; y<h; y++)\n\t\tfor(var x=0; x<w; x++)\n\t\t{\n\t\t\tif(xoff>=0 && yoff>=0) {  si = (y*sw+x)<<2;  ti = (( yoff+y)*tw+xoff+x)<<2;  }\n\t\t\telse                   {  si = ((-yoff+y)*sw-xoff+x)<<2;  ti = (y*tw+x)<<2;  }\n\t\t\t\n\t\t\tif     (mode==0) {  tb[ti] = sb[si];  tb[ti+1] = sb[si+1];  tb[ti+2] = sb[si+2];  tb[ti+3] = sb[si+3];  }\n\t\t\telse if(mode==1) {\n\t\t\t\tvar fa = sb[si+3]*(1/255), fr=sb[si]*fa, fg=sb[si+1]*fa, fb=sb[si+2]*fa; \n\t\t\t\tvar ba = tb[ti+3]*(1/255), br=tb[ti]*ba, bg=tb[ti+1]*ba, bb=tb[ti+2]*ba; \n\t\t\t\t\n\t\t\t\tvar ifa=1-fa, oa = fa+ba*ifa, ioa = (oa==0?0:1/oa);\n\t\t\t\ttb[ti+3] = 255*oa;  \n\t\t\t\ttb[ti+0] = (fr+br*ifa)*ioa;  \n\t\t\t\ttb[ti+1] = (fg+bg*ifa)*ioa;   \n\t\t\t\ttb[ti+2] = (fb+bb*ifa)*ioa;  \n\t\t\t}\n\t\t\telse if(mode==2){\t// copy only differences, otherwise zero\n\t\t\t\tvar fa = sb[si+3], fr=sb[si], fg=sb[si+1], fb=sb[si+2]; \n\t\t\t\tvar ba = tb[ti+3], br=tb[ti], bg=tb[ti+1], bb=tb[ti+2]; \n\t\t\t\tif(fa==ba && fr==br && fg==bg && fb==bb) {  tb[ti]=0;  tb[ti+1]=0;  tb[ti+2]=0;  tb[ti+3]=0;  }\n\t\t\t\telse {  tb[ti]=fr;  tb[ti+1]=fg;  tb[ti+2]=fb;  tb[ti+3]=fa;  }\n\t\t\t}\n\t\t\telse if(mode==3){\t// check if can be blended\n\t\t\t\tvar fa = sb[si+3], fr=sb[si], fg=sb[si+1], fb=sb[si+2]; \n\t\t\t\tvar ba = tb[ti+3], br=tb[ti], bg=tb[ti+1], bb=tb[ti+2]; \n\t\t\t\tif(fa==ba && fr==br && fg==bg && fb==bb) continue;\n\t\t\t\t//if(fa!=255 && ba!=0) return false;\n\t\t\t\tif(fa<220 && ba>20) return false;\n\t\t\t}\n\t\t}\n\treturn true;\n}\n\n\n\n\nUPNG.encode = function(bufs, w, h, ps, dels, tabs, forbidPlte)\n{\n\tif(ps==null) ps=0;\n\tif(forbidPlte==null) forbidPlte = false;\n\n\tvar nimg = UPNG.encode.compress(bufs, w, h, ps, [false, false, false, 0, forbidPlte]);\n\tUPNG.encode.compressPNG(nimg, -1);\n\t\n\treturn UPNG.encode._main(nimg, w, h, dels, tabs);\n}\n\nUPNG.encodeLL = function(bufs, w, h, cc, ac, depth, dels, tabs) {\n\tvar nimg = {  ctype: 0 + (cc==1 ? 0 : 2) + (ac==0 ? 0 : 4),      depth: depth,  frames: []  };\n\t\n\tvar time = Date.now();\n\tvar bipp = (cc+ac)*depth, bipl = bipp * w;\n\tfor(var i=0; i<bufs.length; i++)\n\t\tnimg.frames.push({  rect:{x:0,y:0,width:w,height:h},  img:new Uint8Array(bufs[i]), blend:0, dispose:1, bpp:Math.ceil(bipp/8), bpl:Math.ceil(bipl/8)  });\n\t\n\tUPNG.encode.compressPNG(nimg, 0, true);\n\t\n\tvar out = UPNG.encode._main(nimg, w, h, dels, tabs);\n\treturn out;\n}\n\nUPNG.encode._main = function(nimg, w, h, dels, tabs) {\n\tif(tabs==null) tabs={};\n\tvar crc = UPNG.crc.crc, wUi = UPNG._bin.writeUint, wUs = UPNG._bin.writeUshort, wAs = UPNG._bin.writeASCII;\n\tvar offset = 8, anim = nimg.frames.length>1, pltAlpha = false;\n\t\n\tvar leng = 8 + (16+5+4) /*+ (9+4)*/ + (anim ? 20 : 0);\n\tif(tabs[\"sRGB\"]!=null) leng += 8+1+4;\n\tif(tabs[\"pHYs\"]!=null) leng += 8+9+4;\n\tif(nimg.ctype==3) {\n\t\tvar dl = nimg.plte.length;\n\t\tfor(var i=0; i<dl; i++) if((nimg.plte[i]>>>24)!=255) pltAlpha = true;\n\t\tleng += (8 + dl*3 + 4) + (pltAlpha ? (8 + dl*1 + 4) : 0);\n\t}\n\tfor(var j=0; j<nimg.frames.length; j++)\n\t{\n\t\tvar fr = nimg.frames[j];\n\t\tif(anim) leng += 38;\n\t\tleng += fr.cimg.length + 12;\n\t\tif(j!=0) leng+=4;\n\t}\n\tleng += 12; \n\t\n\tvar data = new Uint8Array(leng);\n\tvar wr=[0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a];\n\tfor(var i=0; i<8; i++) data[i]=wr[i];\n\t\n\twUi(data,offset, 13);     offset+=4;\n\twAs(data,offset,\"IHDR\");  offset+=4;\n\twUi(data,offset,w);  offset+=4;\n\twUi(data,offset,h);  offset+=4;\n\tdata[offset] = nimg.depth;  offset++;  // depth\n\tdata[offset] = nimg.ctype;  offset++;  // ctype\n\tdata[offset] = 0;  offset++;  // compress\n\tdata[offset] = 0;  offset++;  // filter\n\tdata[offset] = 0;  offset++;  // interlace\n\twUi(data,offset,crc(data,offset-17,17));  offset+=4; // crc\n\n\t// 13 bytes to say, that it is sRGB\n\tif(tabs[\"sRGB\"]!=null) {\n\t\twUi(data,offset, 1);      offset+=4;\n\t\twAs(data,offset,\"sRGB\");  offset+=4;\n\t\tdata[offset] = tabs[\"sRGB\"];  offset++;\n\t\twUi(data,offset,crc(data,offset-5,5));  offset+=4; // crc\n\t}\n\tif(tabs[\"pHYs\"]!=null) {\n\t\twUi(data,offset, 9);      offset+=4;\n\t\twAs(data,offset,\"pHYs\");  offset+=4;\n\t\twUi(data,offset, tabs[\"pHYs\"][0]);      offset+=4;\n\t\twUi(data,offset, tabs[\"pHYs\"][1]);      offset+=4;\n\t\tdata[offset]=tabs[\"pHYs\"][2];\t\t\toffset++;\n\t\twUi(data,offset,crc(data,offset-13,13));  offset+=4; // crc\n\t}\n\n\tif(anim) {\n\t\twUi(data,offset, 8);      offset+=4;\n\t\twAs(data,offset,\"acTL\");  offset+=4;\n\t\twUi(data,offset, nimg.frames.length);     offset+=4;\n\t\twUi(data,offset, tabs[\"loop\"]!=null?tabs[\"loop\"]:0);      offset+=4;\n\t\twUi(data,offset,crc(data,offset-12,12));  offset+=4; // crc\n\t}\n\n\tif(nimg.ctype==3) {\n\t\tvar dl = nimg.plte.length;\n\t\twUi(data,offset, dl*3);  offset+=4;\n\t\twAs(data,offset,\"PLTE\");  offset+=4;\n\t\tfor(var i=0; i<dl; i++){\n\t\t\tvar ti=i*3, c=nimg.plte[i], r=(c)&255, g=(c>>>8)&255, b=(c>>>16)&255;\n\t\t\tdata[offset+ti+0]=r;  data[offset+ti+1]=g;  data[offset+ti+2]=b;\n\t\t}\n\t\toffset+=dl*3;\n\t\twUi(data,offset,crc(data,offset-dl*3-4,dl*3+4));  offset+=4; // crc\n\n\t\tif(pltAlpha) {\n\t\t\twUi(data,offset, dl);  offset+=4;\n\t\t\twAs(data,offset,\"tRNS\");  offset+=4;\n\t\t\tfor(var i=0; i<dl; i++)  data[offset+i]=(nimg.plte[i]>>>24)&255;\n\t\t\toffset+=dl;\n\t\t\twUi(data,offset,crc(data,offset-dl-4,dl+4));  offset+=4; // crc\n\t\t}\n\t}\n\t\n\tvar fi = 0;\n\tfor(var j=0; j<nimg.frames.length; j++)\n\t{\n\t\tvar fr = nimg.frames[j];\n\t\tif(anim) {\n\t\t\twUi(data, offset, 26);     offset+=4;\n\t\t\twAs(data, offset,\"fcTL\");  offset+=4;\n\t\t\twUi(data, offset, fi++);   offset+=4;\n\t\t\twUi(data, offset, fr.rect.width );   offset+=4;\n\t\t\twUi(data, offset, fr.rect.height);   offset+=4;\n\t\t\twUi(data, offset, fr.rect.x);   offset+=4;\n\t\t\twUi(data, offset, fr.rect.y);   offset+=4;\n\t\t\twUs(data, offset, dels[j]);   offset+=2;\n\t\t\twUs(data, offset,  1000);   offset+=2;\n\t\t\tdata[offset] = fr.dispose;  offset++;\t// dispose\n\t\t\tdata[offset] = fr.blend  ;  offset++;\t// blend\n\t\t\twUi(data,offset,crc(data,offset-30,30));  offset+=4; // crc\n\t\t}\n\t\t\t\t\n\t\tvar imgd = fr.cimg, dl = imgd.length;\n\t\twUi(data,offset, dl+(j==0?0:4));     offset+=4;\n\t\tvar ioff = offset;\n\t\twAs(data,offset,(j==0)?\"IDAT\":\"fdAT\");  offset+=4;\n\t\tif(j!=0) {  wUi(data, offset, fi++);  offset+=4;  }\n\t\tdata.set(imgd,offset);\n\t\toffset += dl;\n\t\twUi(data,offset,crc(data,ioff,offset-ioff));  offset+=4; // crc\n\t}\n\n\twUi(data,offset, 0);     offset+=4;\n\twAs(data,offset,\"IEND\");  offset+=4;\n\twUi(data,offset,crc(data,offset-4,4));  offset+=4; // crc\n\n\treturn data.buffer;\n}\n\nUPNG.encode.compressPNG = function(out, filter, levelZero) {\n\tfor(var i=0; i<out.frames.length; i++) {\n\t\tvar frm = out.frames[i], nw=frm.rect.width, nh=frm.rect.height;\n\t\tvar fdata = new Uint8Array(nh*frm.bpl+nh);\n\t\tfrm.cimg = UPNG.encode._filterZero(frm.img,nh,frm.bpp,frm.bpl,fdata, filter, levelZero);\n\t}\n}\n\n\n\nUPNG.encode.compress = function(bufs, w, h, ps, prms) // prms:  onlyBlend, minBits, forbidPlte\n{\n\t//var time = Date.now();\n\tvar onlyBlend = prms[0], evenCrd = prms[1], forbidPrev = prms[2], minBits = prms[3], forbidPlte = prms[4];\n\t\n\tvar ctype = 6, depth = 8, alphaAnd=255\n\t\n\tfor(var j=0; j<bufs.length; j++)  {  // when not quantized, other frames can contain colors, that are not in an initial frame\n\t\tvar img = new Uint8Array(bufs[j]), ilen = img.length;\n\t\tfor(var i=0; i<ilen; i+=4) alphaAnd &= img[i+3];\n\t}\n\tvar gotAlpha = (alphaAnd!=255);\n\t\n\t//console.log(\"alpha check\", Date.now()-time);  time = Date.now();\n\t\n\t//var brute = gotAlpha && forGIF;\t\t// brute : frames can only be copied, not \"blended\"\n\tvar frms = UPNG.encode.framize(bufs, w, h, onlyBlend, evenCrd, forbidPrev);\n\t//console.log(\"framize\", Date.now()-time);  time = Date.now();\n\t\n\tvar cmap={}, plte=[], inds=[];  \n\t\n\tif(ps!=0) {\n\t\tvar nbufs = [];  for(var i=0; i<frms.length; i++) nbufs.push(frms[i].img.buffer);\n\t\t\n\t\tvar abuf = UPNG.encode.concatRGBA(nbufs), qres = UPNG.quantize(abuf, ps);  \n\t\tvar cof = 0, bb = new Uint8Array(qres.abuf);\n\t\tfor(var i=0; i<frms.length; i++) {  var ti=frms[i].img, bln=ti.length;  inds.push(new Uint8Array(qres.inds.buffer, cof>>2, bln>>2));\n\t\t\tfor(var j=0; j<bln; j+=4) {  ti[j]=bb[cof+j];  ti[j+1]=bb[cof+j+1];  ti[j+2]=bb[cof+j+2];  ti[j+3]=bb[cof+j+3];  }    cof+=bln;  }\n\t\t\n\t\tfor(var i=0; i<qres.plte.length; i++) plte.push(qres.plte[i].est.rgba);\n\t\t//console.log(\"quantize\", Date.now()-time);  time = Date.now();\n\t}\n\telse {\n\t\t// what if ps==0, but there are <=256 colors?  we still need to detect, if the palette could be used\n\t\tfor(var j=0; j<frms.length; j++)  {  // when not quantized, other frames can contain colors, that are not in an initial frame\n\t\t\tvar frm = frms[j], img32 = new Uint32Array(frm.img.buffer), nw=frm.rect.width, ilen = img32.length;\n\t\t\tvar ind = new Uint8Array(ilen);  inds.push(ind);\n\t\t\tfor(var i=0; i<ilen; i++) {\n\t\t\t\tvar c = img32[i];\n\t\t\t\tif     (i!=0 && c==img32[i- 1]) ind[i]=ind[i-1];\n\t\t\t\telse if(i>nw && c==img32[i-nw]) ind[i]=ind[i-nw];\n\t\t\t\telse {\n\t\t\t\t\tvar cmc = cmap[c];\n\t\t\t\t\tif(cmc==null) {  cmap[c]=cmc=plte.length;  plte.push(c);  if(plte.length>=300) break;  }\n\t\t\t\t\tind[i]=cmc;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//console.log(\"make palette\", Date.now()-time);  time = Date.now();\n\t}\n\t\n\tvar cc=plte.length; //console.log(\"colors:\",cc);\n\tif(cc<=256 && forbidPlte==false) {\n\t\tif(cc<= 2) depth=1;  else if(cc<= 4) depth=2;  else if(cc<=16) depth=4;  else depth=8;\n\t\tdepth =  Math.max(depth, minBits);\n\t}\n\t\n\tfor(var j=0; j<frms.length; j++)\n\t{\n\t\tvar frm = frms[j], nx=frm.rect.x, ny=frm.rect.y, nw=frm.rect.width, nh=frm.rect.height;\n\t\tvar cimg = frm.img, cimg32 = new Uint32Array(cimg.buffer);\n\t\tvar bpl = 4*nw, bpp=4;\n\t\tif(cc<=256 && forbidPlte==false) {\n\t\t\tbpl = Math.ceil(depth*nw/8);\n\t\t\tvar nimg = new Uint8Array(bpl*nh);\n\t\t\tvar inj = inds[j];\n\t\t\tfor(var y=0; y<nh; y++) {  var i=y*bpl, ii=y*nw;\n\t\t\t\tif     (depth==8) for(var x=0; x<nw; x++) nimg[i+(x)   ]   =  (inj[ii+x]             );\n\t\t\t\telse if(depth==4) for(var x=0; x<nw; x++) nimg[i+(x>>1)]  |=  (inj[ii+x]<<(4-(x&1)*4));\n\t\t\t\telse if(depth==2) for(var x=0; x<nw; x++) nimg[i+(x>>2)]  |=  (inj[ii+x]<<(6-(x&3)*2));\n\t\t\t\telse if(depth==1) for(var x=0; x<nw; x++) nimg[i+(x>>3)]  |=  (inj[ii+x]<<(7-(x&7)*1));\n\t\t\t}\n\t\t\tcimg=nimg;  ctype=3;  bpp=1;\n\t\t}\n\t\telse if(gotAlpha==false && frms.length==1) {\t// some next \"reduced\" frames may contain alpha for blending\n\t\t\tvar nimg = new Uint8Array(nw*nh*3), area=nw*nh;\n\t\t\tfor(var i=0; i<area; i++) { var ti=i*3, qi=i*4;  nimg[ti]=cimg[qi];  nimg[ti+1]=cimg[qi+1];  nimg[ti+2]=cimg[qi+2];  }\n\t\t\tcimg=nimg;  ctype=2;  bpp=3;  bpl=3*nw;\n\t\t}\n\t\tfrm.img=cimg;  frm.bpl=bpl;  frm.bpp=bpp;\n\t}\n\t//console.log(\"colors => palette indices\", Date.now()-time);  time = Date.now();\n\t\n\treturn {ctype:ctype, depth:depth, plte:plte, frames:frms  };\n}\nUPNG.encode.framize = function(bufs,w,h,alwaysBlend,evenCrd,forbidPrev) {\n\t/*  DISPOSE\n\t    - 0 : no change\n\t\t- 1 : clear to transparent\n\t\t- 2 : retstore to content before rendering (previous frame disposed)\n\t\tBLEND\n\t\t- 0 : replace\n\t\t- 1 : blend\n\t*/\n\tvar frms = [];\n\tfor(var j=0; j<bufs.length; j++) {\n\t\tvar cimg = new Uint8Array(bufs[j]), cimg32 = new Uint32Array(cimg.buffer);\n\t\tvar nimg;\n\t\t\n\t\tvar nx=0, ny=0, nw=w, nh=h, blend=alwaysBlend?1:0;\n\t\tif(j!=0) {\n\t\t\tvar tlim = (forbidPrev || alwaysBlend || j==1 || frms[j-2].dispose!=0)?1:2, tstp = 0, tarea = 1e9;\n\t\t\tfor(var it=0; it<tlim; it++)\n\t\t\t{\n\t\t\t\tvar pimg = new Uint8Array(bufs[j-1-it]), p32 = new Uint32Array(bufs[j-1-it]);\n\t\t\t\tvar mix=w,miy=h,max=-1,may=-1;\n\t\t\t\tfor(var y=0; y<h; y++) for(var x=0; x<w; x++) {\n\t\t\t\t\tvar i = y*w+x;\n\t\t\t\t\tif(cimg32[i]!=p32[i]) {\n\t\t\t\t\t\tif(x<mix) mix=x;  if(x>max) max=x;\n\t\t\t\t\t\tif(y<miy) miy=y;  if(y>may) may=y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(max==-1) mix=miy=max=may=0;\n\t\t\t\tif(evenCrd) {  if((mix&1)==1)mix--;  if((miy&1)==1)miy--;  }\n\t\t\t\tvar sarea = (max-mix+1)*(may-miy+1);\n\t\t\t\tif(sarea<tarea) {\n\t\t\t\t\ttarea = sarea;  tstp = it;\n\t\t\t\t\tnx = mix; ny = miy; nw = max-mix+1; nh = may-miy+1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// alwaysBlend: pokud zjistím, že blendit nelze, nastavím předchozímu snímku dispose=1. Zajistím, aby obsahoval můj obdélník.\n\t\t\tvar pimg = new Uint8Array(bufs[j-1-tstp]);\n\t\t\tif(tstp==1) frms[j-1].dispose = 2;\n\t\t\t\n\t\t\tnimg = new Uint8Array(nw*nh*4);\n\t\t\tUPNG._copyTile(pimg,w,h, nimg,nw,nh, -nx,-ny, 0);\n\t\t\t\n\t\t\tblend =  UPNG._copyTile(cimg,w,h, nimg,nw,nh, -nx,-ny, 3) ? 1 : 0;\n\t\t\tif(blend==1) UPNG.encode._prepareDiff(cimg,w,h,nimg,{x:nx,y:ny,width:nw,height:nh});\n\t\t\telse         UPNG._copyTile(cimg,w,h, nimg,nw,nh, -nx,-ny, 0);\n\t\t\t//UPNG._copyTile(cimg,w,h, nimg,nw,nh, -nx,-ny, blend==1?2:0);\n\t\t}\n\t\telse nimg = cimg.slice(0);\t// img may be rewritten further ... don't rewrite input\n\t\t\n\t\tfrms.push({rect:{x:nx,y:ny,width:nw,height:nh}, img:nimg, blend:blend, dispose:0});\n\t}\n\t\n\t\n\tif(alwaysBlend) for(var j=0; j<frms.length; j++) {\n\t\tvar frm = frms[j];  if(frm.blend==1) continue;\n\t\tvar r0 = frm.rect, r1 = frms[j-1].rect\n\t\tvar miX = Math.min(r0.x, r1.x), miY = Math.min(r0.y, r1.y);\n\t\tvar maX = Math.max(r0.x+r0.width, r1.x+r1.width), maY = Math.max(r0.y+r0.height, r1.y+r1.height);\n\t\tvar r = {x:miX, y:miY, width:maX-miX, height:maY-miY};\n\t\t\n\t\tfrms[j-1].dispose = 1;\n\t\tif(j-1!=0) \n\t\tUPNG.encode._updateFrame(bufs, w,h,frms, j-1,r, evenCrd);\n\t\tUPNG.encode._updateFrame(bufs, w,h,frms, j  ,r, evenCrd);\n\t}\n\tvar area = 0;\n\tif(bufs.length!=1) for(var i=0; i<frms.length; i++) {\n\t\tvar frm = frms[i];\n\t\tarea += frm.rect.width*frm.rect.height;\n\t\t//if(i==0 || frm.blend!=1) continue;\n\t\t//var ob = new Uint8Array(\n\t\t//console.log(frm.blend, frm.dispose, frm.rect);\n\t}\n\t//if(area!=0) console.log(area);\n\treturn frms;\n}\nUPNG.encode._updateFrame = function(bufs, w,h, frms, i, r, evenCrd) {\n\tvar U8 = Uint8Array, U32 = Uint32Array;\n\tvar pimg = new U8(bufs[i-1]), pimg32 = new U32(bufs[i-1]), nimg = i+1<bufs.length ? new U8(bufs[i+1]):null;\n\tvar cimg = new U8(bufs[i]), cimg32 = new U32(cimg.buffer);\n\t\n\tvar mix=w,miy=h,max=-1,may=-1;\n\tfor(var y=0; y<r.height; y++) for(var x=0; x<r.width; x++) {\n\t\tvar cx = r.x+x, cy = r.y+y;\n\t\tvar j = cy*w+cx, cc = cimg32[j];\n\t\t// no need to draw transparency, or to dispose it. Or, if writing the same color and the next one does not need transparency.\n\t\tif(cc==0 || (frms[i-1].dispose==0 && pimg32[j]==cc && (nimg==null || nimg[j*4+3]!=0))/**/) {}\n\t\telse {\n\t\t\tif(cx<mix) mix=cx;  if(cx>max) max=cx;\n\t\t\tif(cy<miy) miy=cy;  if(cy>may) may=cy;\n\t\t}\n\t}\n\tif(max==-1) mix=miy=max=may=0;\n\tif(evenCrd) {  if((mix&1)==1)mix--;  if((miy&1)==1)miy--;  }\n\tr = {x:mix, y:miy, width:max-mix+1, height:may-miy+1};\n\t\n\tvar fr = frms[i];  fr.rect = r;  fr.blend = 1;  fr.img = new Uint8Array(r.width*r.height*4);\n\tif(frms[i-1].dispose==0) {\n\t\tUPNG._copyTile(pimg,w,h, fr.img,r.width,r.height, -r.x,-r.y, 0);\n\t\tUPNG.encode._prepareDiff(cimg,w,h,fr.img,r);\n\t\t//UPNG._copyTile(cimg,w,h, fr.img,r.width,r.height, -r.x,-r.y, 2);\n\t}\n\telse\n\t\tUPNG._copyTile(cimg,w,h, fr.img,r.width,r.height, -r.x,-r.y, 0);\n}\nUPNG.encode._prepareDiff = function(cimg, w,h, nimg, rec) {\n\tUPNG._copyTile(cimg,w,h, nimg,rec.width,rec.height, -rec.x,-rec.y, 2);\n\t/*\n\tvar n32 = new Uint32Array(nimg.buffer);\n\tvar og = new Uint8Array(rec.width*rec.height*4), o32 = new Uint32Array(og.buffer);\n\tUPNG._copyTile(cimg,w,h, og,rec.width,rec.height, -rec.x,-rec.y, 0);\n\tfor(var i=4; i<nimg.length; i+=4) {\n\t\tif(nimg[i-1]!=0 && nimg[i+3]==0 && o32[i>>>2]==o32[(i>>>2)-1]) {\n\t\t\tn32[i>>>2]=o32[i>>>2];\n\t\t\t//var j = i, c=p32[(i>>>2)-1];\n\t\t\t//while(p32[j>>>2]==c) {  n32[j>>>2]=c;  j+=4;  }\n\t\t}\n\t}\n\tfor(var i=nimg.length-8; i>0; i-=4) {\n\t\tif(nimg[i+7]!=0 && nimg[i+3]==0 && o32[i>>>2]==o32[(i>>>2)+1]) {\n\t\t\tn32[i>>>2]=o32[i>>>2];\n\t\t\t//var j = i, c=p32[(i>>>2)-1];\n\t\t\t//while(p32[j>>>2]==c) {  n32[j>>>2]=c;  j+=4;  }\n\t\t}\n\t}*/\n}\n\nUPNG.encode._filterZero = function(img,h,bpp,bpl,data, filter, levelZero)\n{\n\tvar fls = [], ftry=[0,1,2,3,4];\n\tif     (filter!=-1)             ftry=[filter];\n\telse if(h*bpl>500000 || bpp==1) ftry=[0];\n\tvar opts;  if(levelZero) opts={level:0};\n\t\n\tvar CMPR = (levelZero && UZIP!=null) ? UZIP : (pako__WEBPACK_IMPORTED_MODULE_0___default());\n\t\n\tfor(var i=0; i<ftry.length; i++) {\n\t\tfor(var y=0; y<h; y++) UPNG.encode._filterLine(data, img, y, bpl, bpp, ftry[i]);\n\t\t//var nimg = new Uint8Array(data.length);\n\t\t//var sz = UZIP.F.deflate(data, nimg);  fls.push(nimg.slice(0,sz));\n\t\t//var dfl = pako[\"deflate\"](data), dl=dfl.length-4;\n\t\t//var crc = (dfl[dl+3]<<24)|(dfl[dl+2]<<16)|(dfl[dl+1]<<8)|(dfl[dl+0]<<0);\n\t\t//console.log(crc, UZIP.adler(data,2,data.length-6));\n\t\tfls.push(CMPR[\"deflate\"](data,opts));\n\t}\n\tvar ti, tsize=1e9;\n\tfor(var i=0; i<fls.length; i++) if(fls[i].length<tsize) {  ti=i;  tsize=fls[i].length;  }\n\treturn fls[ti];\n}\nUPNG.encode._filterLine = function(data, img, y, bpl, bpp, type)\n{\n\tvar i = y*bpl, di = i+y, paeth = UPNG.decode._paeth\n\tdata[di]=type;  di++;\n\n\tif(type==0) {\n\t\tif(bpl<500) for(var x=0; x<bpl; x++) data[di+x] = img[i+x];\n\t\telse data.set(new Uint8Array(img.buffer,i,bpl),di);\n\t}\n\telse if(type==1) {\n\t\tfor(var x=  0; x<bpp; x++) data[di+x] =  img[i+x];\n\t\tfor(var x=bpp; x<bpl; x++) data[di+x] = (img[i+x]-img[i+x-bpp]+256)&255;\n\t}\n\telse if(y==0) {\n\t\tfor(var x=  0; x<bpp; x++) data[di+x] = img[i+x];\n\n\t\tif(type==2) for(var x=bpp; x<bpl; x++) data[di+x] = img[i+x];\n\t\tif(type==3) for(var x=bpp; x<bpl; x++) data[di+x] = (img[i+x] - (img[i+x-bpp]>>1) +256)&255;\n\t\tif(type==4) for(var x=bpp; x<bpl; x++) data[di+x] = (img[i+x] - paeth(img[i+x-bpp], 0, 0) +256)&255;\n\t}\n\telse {\n\t\tif(type==2) { for(var x=  0; x<bpl; x++) data[di+x] = (img[i+x]+256 - img[i+x-bpl])&255;  }\n\t\tif(type==3) { for(var x=  0; x<bpp; x++) data[di+x] = (img[i+x]+256 - (img[i+x-bpl]>>1))&255;\n\t\t\t\t\t  for(var x=bpp; x<bpl; x++) data[di+x] = (img[i+x]+256 - ((img[i+x-bpl]+img[i+x-bpp])>>1))&255;  }\n\t\tif(type==4) { for(var x=  0; x<bpp; x++) data[di+x] = (img[i+x]+256 - paeth(0, img[i+x-bpl], 0))&255;\n\t\t\t\t\t  for(var x=bpp; x<bpl; x++) data[di+x] = (img[i+x]+256 - paeth(img[i+x-bpp], img[i+x-bpl], img[i+x-bpp-bpl]))&255;  }\n\t}\n}\n\nUPNG.crc = {\n\ttable : ( function() {\n\t   var tab = new Uint32Array(256);\n\t   for (var n=0; n<256; n++) {\n\t\t\tvar c = n;\n\t\t\tfor (var k=0; k<8; k++) {\n\t\t\t\tif (c & 1)  c = 0xedb88320 ^ (c >>> 1);\n\t\t\t\telse        c = c >>> 1;\n\t\t\t}\n\t\t\ttab[n] = c;  }\n\t\treturn tab;  })(),\n\tupdate : function(c, buf, off, len) {\n\t\tfor (var i=0; i<len; i++)  c = UPNG.crc.table[(c ^ buf[off+i]) & 0xff] ^ (c >>> 8);\n\t\treturn c;\n\t},\n\tcrc : function(b,o,l)  {  return UPNG.crc.update(0xffffffff,b,o,l) ^ 0xffffffff;  }\n}\n\n\nUPNG.quantize = function(abuf, ps)\n{\t\n\tvar oimg = new Uint8Array(abuf), nimg = oimg.slice(0), nimg32 = new Uint32Array(nimg.buffer);\n\t\n\tvar KD = UPNG.quantize.getKDtree(nimg, ps);\n\tvar root = KD[0], leafs = KD[1];\n\t\n\tvar planeDst = UPNG.quantize.planeDst;\n\tvar sb = oimg, tb = nimg32, len=sb.length;\n\t\t\n\tvar inds = new Uint8Array(oimg.length>>2);\n\tfor(var i=0; i<len; i+=4) {\n\t\tvar r=sb[i]*(1/255), g=sb[i+1]*(1/255), b=sb[i+2]*(1/255), a=sb[i+3]*(1/255);\n\t\t\n\t\t//  exact, but too slow :(\n\t\tvar nd = UPNG.quantize.getNearest(root, r, g, b, a);\n\t\t//var nd = root;\n\t\t//while(nd.left) nd = (planeDst(nd.est,r,g,b,a)<=0) ? nd.left : nd.right;\n\t\t\n\t\tinds[i>>2] = nd.ind;\n\t\ttb[i>>2] = nd.est.rgba;\n\t}\n\treturn {  abuf:nimg.buffer, inds:inds, plte:leafs  };\n}\n\nUPNG.quantize.getKDtree = function(nimg, ps, err) {\n\tif(err==null) err = 0.0001;\n\tvar nimg32 = new Uint32Array(nimg.buffer);\n\t\n\tvar root = {i0:0, i1:nimg.length, bst:null, est:null, tdst:0, left:null, right:null };  // basic statistic, extra statistic\n\troot.bst = UPNG.quantize.stats(  nimg,root.i0, root.i1  );  root.est = UPNG.quantize.estats( root.bst );\n\tvar leafs = [root];\n\t\n\twhile(leafs.length<ps)\n\t{\n\t\tvar maxL = 0, mi=0;\n\t\tfor(var i=0; i<leafs.length; i++) if(leafs[i].est.L > maxL) {  maxL=leafs[i].est.L;  mi=i;  }\n\t\tif(maxL<err) break;\n\t\tvar node = leafs[mi];\n\t\t\n\t\tvar s0 = UPNG.quantize.splitPixels(nimg,nimg32, node.i0, node.i1, node.est.e, node.est.eMq255);\n\t\tvar s0wrong = (node.i0>=s0 || node.i1<=s0);\n\t\t//console.log(maxL, leafs.length, mi);\n\t\tif(s0wrong) {  node.est.L=0;  continue;  }\n\t\t\n\t\t\n\t\tvar ln = {i0:node.i0, i1:s0, bst:null, est:null, tdst:0, left:null, right:null };  ln.bst = UPNG.quantize.stats( nimg, ln.i0, ln.i1 );  \n\t\tln.est = UPNG.quantize.estats( ln.bst );\n\t\tvar rn = {i0:s0, i1:node.i1, bst:null, est:null, tdst:0, left:null, right:null };  rn.bst = {R:[], m:[], N:node.bst.N-ln.bst.N};\n\t\tfor(var i=0; i<16; i++) rn.bst.R[i] = node.bst.R[i]-ln.bst.R[i];\n\t\tfor(var i=0; i< 4; i++) rn.bst.m[i] = node.bst.m[i]-ln.bst.m[i];\n\t\trn.est = UPNG.quantize.estats( rn.bst );\n\t\t\n\t\tnode.left = ln;  node.right = rn;\n\t\tleafs[mi]=ln;  leafs.push(rn);\n\t}\n\tleafs.sort(function(a,b) {  return b.bst.N-a.bst.N;  });\n\tfor(var i=0; i<leafs.length; i++) leafs[i].ind=i;\n\treturn [root, leafs];\n}\n\nUPNG.quantize.getNearest = function(nd, r,g,b,a)\n{\n\tif(nd.left==null) {  nd.tdst = UPNG.quantize.dist(nd.est.q,r,g,b,a);  return nd;  }\n\tvar planeDst = UPNG.quantize.planeDst(nd.est,r,g,b,a);\n\t\n\tvar node0 = nd.left, node1 = nd.right;\n\tif(planeDst>0) {  node0=nd.right;  node1=nd.left;  }\n\t\n\tvar ln = UPNG.quantize.getNearest(node0, r,g,b,a);\n\tif(ln.tdst<=planeDst*planeDst) return ln;\n\tvar rn = UPNG.quantize.getNearest(node1, r,g,b,a);\n\treturn rn.tdst<ln.tdst ? rn : ln;\n}\nUPNG.quantize.planeDst = function(est, r,g,b,a) {  var e = est.e;  return e[0]*r + e[1]*g + e[2]*b + e[3]*a - est.eMq;  }\nUPNG.quantize.dist     = function(q,   r,g,b,a) {  var d0=r-q[0], d1=g-q[1], d2=b-q[2], d3=a-q[3];  return d0*d0+d1*d1+d2*d2+d3*d3;  }\n\nUPNG.quantize.splitPixels = function(nimg, nimg32, i0, i1, e, eMq)\n{\n\tvar vecDot = UPNG.quantize.vecDot;\n\ti1-=4;\n\tvar shfs = 0;\n\twhile(i0<i1)\n\t{\n\t\twhile(vecDot(nimg, i0, e)<=eMq) i0+=4;\n\t\twhile(vecDot(nimg, i1, e)> eMq) i1-=4;\n\t\tif(i0>=i1) break;\n\t\t\n\t\tvar t = nimg32[i0>>2];  nimg32[i0>>2] = nimg32[i1>>2];  nimg32[i1>>2]=t;\n\t\t\n\t\ti0+=4;  i1-=4;\n\t}\n\twhile(vecDot(nimg, i0, e)>eMq) i0-=4;\n\treturn i0+4;\n}\nUPNG.quantize.vecDot = function(nimg, i, e)\n{\n\treturn nimg[i]*e[0] + nimg[i+1]*e[1] + nimg[i+2]*e[2] + nimg[i+3]*e[3];\n}\nUPNG.quantize.stats = function(nimg, i0, i1){\n\tvar R = [0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0];\n\tvar m = [0,0,0,0];\n\tvar N = (i1-i0)>>2;\n\tfor(var i=i0; i<i1; i+=4)\n\t{\n\t\tvar r = nimg[i]*(1/255), g = nimg[i+1]*(1/255), b = nimg[i+2]*(1/255), a = nimg[i+3]*(1/255);\n\t\t//var r = nimg[i], g = nimg[i+1], b = nimg[i+2], a = nimg[i+3];\n\t\tm[0]+=r;  m[1]+=g;  m[2]+=b;  m[3]+=a;\n\t\t\n\t\tR[ 0] += r*r;  R[ 1] += r*g;  R[ 2] += r*b;  R[ 3] += r*a;  \n\t\t               R[ 5] += g*g;  R[ 6] += g*b;  R[ 7] += g*a; \n\t\t                              R[10] += b*b;  R[11] += b*a;  \n\t\t                                             R[15] += a*a;  \n\t}\n\tR[4]=R[1];  R[8]=R[2];  R[9]=R[6];  R[12]=R[3];  R[13]=R[7];  R[14]=R[11];\n\t\n\treturn {R:R, m:m, N:N};\n}\nUPNG.quantize.estats = function(stats){\n\tvar R = stats.R, m = stats.m, N = stats.N;\n\t\n\t// when all samples are equal, but N is large (millions), the Rj can be non-zero ( 0.0003.... - precission error)\n\tvar m0 = m[0], m1 = m[1], m2 = m[2], m3 = m[3], iN = (N==0 ? 0 : 1/N);\n\tvar Rj = [\n\t\tR[ 0] - m0*m0*iN,  R[ 1] - m0*m1*iN,  R[ 2] - m0*m2*iN,  R[ 3] - m0*m3*iN,  \n\t\tR[ 4] - m1*m0*iN,  R[ 5] - m1*m1*iN,  R[ 6] - m1*m2*iN,  R[ 7] - m1*m3*iN,\n\t\tR[ 8] - m2*m0*iN,  R[ 9] - m2*m1*iN,  R[10] - m2*m2*iN,  R[11] - m2*m3*iN,  \n\t\tR[12] - m3*m0*iN,  R[13] - m3*m1*iN,  R[14] - m3*m2*iN,  R[15] - m3*m3*iN \n\t];\n\t\n\tvar A = Rj, M = UPNG.M4;\n\tvar b = [0.5,0.5,0.5,0.5], mi = 0, tmi = 0;\n\t\n\tif(N!=0)\n\tfor(var i=0; i<10; i++) {\n\t\tb = M.multVec(A, b);  tmi = Math.sqrt(M.dot(b,b));  b = M.sml(1/tmi,  b);\n\t\tif(Math.abs(tmi-mi)<1e-9) break;  mi = tmi;\n\t}\t\n\t//b = [0,0,1,0];  mi=N;\n\tvar q = [m0*iN, m1*iN, m2*iN, m3*iN];\n\tvar eMq255 = M.dot(M.sml(255,q),b);\n\t\n\treturn {  Cov:Rj, q:q, e:b, L:mi,  eMq255:eMq255, eMq : M.dot(b,q),\n\t\t\t\trgba: (((Math.round(255*q[3])<<24) | (Math.round(255*q[2])<<16) |  (Math.round(255*q[1])<<8) | (Math.round(255*q[0])<<0))>>>0)  };\n}\nUPNG.M4 = {\n\tmultVec : function(m,v) {\n\t\t\treturn [\n\t\t\t\tm[ 0]*v[0] + m[ 1]*v[1] + m[ 2]*v[2] + m[ 3]*v[3],\n\t\t\t\tm[ 4]*v[0] + m[ 5]*v[1] + m[ 6]*v[2] + m[ 7]*v[3],\n\t\t\t\tm[ 8]*v[0] + m[ 9]*v[1] + m[10]*v[2] + m[11]*v[3],\n\t\t\t\tm[12]*v[0] + m[13]*v[1] + m[14]*v[2] + m[15]*v[3]\n\t\t\t];\n\t},\n\tdot : function(x,y) {  return  x[0]*y[0]+x[1]*y[1]+x[2]*y[2]+x[3]*y[3];  },\n\tsml : function(a,y) {  return [a*y[0],a*y[1],a*y[2],a*y[3]];  }\n}\n\nUPNG.encode.concatRGBA = function(bufs) {\n\tvar tlen = 0;\n\tfor(var i=0; i<bufs.length; i++) tlen += bufs[i].byteLength;\n\tvar nimg = new Uint8Array(tlen), noff=0;\n\tfor(var i=0; i<bufs.length; i++) {\n\t\tvar img = new Uint8Array(bufs[i]), il = img.length;\n\t\tfor(var j=0; j<il; j+=4) {  \n\t\t\tvar r=img[j], g=img[j+1], b=img[j+2], a = img[j+3];\n\t\t\tif(a==0) r=g=b=0;\n\t\t\tnimg[noff+j]=r;  nimg[noff+j+1]=g;  nimg[noff+j+2]=b;  nimg[noff+j+3]=a;  }\n\t\tnoff += il;\n\t}\n\treturn nimg.buffer;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (UPNG);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHBkZi1saWIrdXBuZ0AxLjAuMS9ub2RlX21vZHVsZXMvQHBkZi1saWIvdXBuZy9VUE5HLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF3Qjs7QUFFeEI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxxQkFBcUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckI7QUFDQSw2QkFBNkIsUUFBUSxTQUFTLGtCQUFrQixzQkFBc0Isc0JBQXNCO0FBQzVHLDZCQUE2QixRQUFRLFNBQVM7QUFDOUM7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLDhCQUE4QixRQUFRLFFBQVEsYUFBYTtBQUMzRCw4QkFBOEIsUUFBUSxRQUFRLGFBQWE7QUFDM0Q7QUFDQSxVQUFVO0FBQ1YsOEJBQThCLFFBQVEsUUFBUSxzQkFBc0I7QUFDcEU7QUFDQSw4QkFBOEIsUUFBUSxRQUFRLHNCQUFzQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLDRCQUE0QixLQUFLLFFBQVE7QUFDekMsZ0JBQWdCLEtBQUssT0FBTyxxRUFBcUUsZUFBZSxtQkFBbUIsbUJBQW1CO0FBQ3RKO0FBQ0EsNEJBQTRCLEtBQUssUUFBUTtBQUN6QyxnQkFBZ0IsS0FBSyxPQUFPLHFFQUFxRSxlQUFlLG1CQUFtQixtQkFBbUI7QUFDdEo7QUFDQSw0QkFBNEIsS0FBSyxRQUFRO0FBQ3pDLGdCQUFnQixLQUFLLE9BQU8scUVBQXFFLGVBQWUsbUJBQW1CLG1CQUFtQjtBQUN0SjtB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LGVBQWU7QUFDN0I7QUFDQSxlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUIsbUJBQW1CO0FBQzFEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLElBQUksRUFBQyIsInNvdXJjZXMiOlsiL2hvbWUvdWJ1bnR1L2NlcnRpZmljYXRlX2FwcC9jZXJ0aWZpY2F0ZV9nZW5lcmF0b3IvY2VydGlmaWNhdGVfZ2VuZXJhdG9yL25vZGVfbW9kdWxlcy8ucG5wbS9AcGRmLWxpYit1cG5nQDEuMC4xL25vZGVfbW9kdWxlcy9AcGRmLWxpYi91cG5nL1VQTkcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHBha28gZnJvbSAncGFrbyc7XG5cbnZhciBVUE5HID0ge307XG5cblx0XG5cblVQTkcudG9SR0JBOCA9IGZ1bmN0aW9uKG91dClcbntcblx0dmFyIHcgPSBvdXQud2lkdGgsIGggPSBvdXQuaGVpZ2h0O1xuXHRpZihvdXQudGFicy5hY1RMPT1udWxsKSByZXR1cm4gW1VQTkcudG9SR0JBOC5kZWNvZGVJbWFnZShvdXQuZGF0YSwgdywgaCwgb3V0KS5idWZmZXJdO1xuXHRcblx0dmFyIGZybXMgPSBbXTtcblx0aWYob3V0LmZyYW1lc1swXS5kYXRhPT1udWxsKSBvdXQuZnJhbWVzWzBdLmRhdGEgPSBvdXQuZGF0YTtcblx0XG5cdHZhciBsZW4gPSB3KmgqNCwgaW1nID0gbmV3IFVpbnQ4QXJyYXkobGVuKSwgZW1wdHkgPSBuZXcgVWludDhBcnJheShsZW4pLCBwcmV2PW5ldyBVaW50OEFycmF5KGxlbik7XG5cdGZvcih2YXIgaT0wOyBpPG91dC5mcmFtZXMubGVuZ3RoOyBpKyspXG5cdHtcblx0XHR2YXIgZnJtID0gb3V0LmZyYW1lc1tpXTtcblx0XHR2YXIgZng9ZnJtLnJlY3QueCwgZnk9ZnJtLnJlY3QueSwgZncgPSBmcm0ucmVjdC53aWR0aCwgZmggPSBmcm0ucmVjdC5oZWlnaHQ7XG5cdFx0dmFyIGZkYXRhID0gVVBORy50b1JHQkE4LmRlY29kZUltYWdlKGZybS5kYXRhLCBmdyxmaCwgb3V0KTtcblx0XHRcblx0XHRpZihpIT0wKSBmb3IodmFyIGo9MDsgajxsZW47IGorKykgcHJldltqXT1pbWdbal07XG5cdFx0XG5cdFx0aWYgICAgIChmcm0uYmxlbmQ9PTApIFVQTkcuX2NvcHlUaWxlKGZkYXRhLCBmdywgZmgsIGltZywgdywgaCwgZngsIGZ5LCAwKTtcblx0XHRlbHNlIGlmKGZybS5ibGVuZD09MSkgVVBORy5fY29weVRpbGUoZmRhdGEsIGZ3LCBmaCwgaW1nLCB3LCBoLCBmeCwgZnksIDEpO1xuXHRcdFxuXHRcdGZybXMucHVzaChpbWcuYnVmZmVyLnNsaWNlKDApKTtcblx0XHRcblx0XHRpZiAgICAgKGZybS5kaXNwb3NlPT0wKSB7fVxuXHRcdGVsc2UgaWYoZnJtLmRpc3Bvc2U9PTEpIFVQTkcuX2NvcHlUaWxlKGVtcHR5LCBmdywgZmgsIGltZywgdywgaCwgZngsIGZ5LCAwKTtcblx0XHRlbHNlIGlmKGZybS5kaXNwb3NlPT0yKSBmb3IodmFyIGo9MDsgajxsZW47IGorKykgaW1nW2pdPXByZXZbal07XG5cdH1cblx0cmV0dXJuIGZybXM7XG59XG5VUE5HLnRvUkdCQTguZGVjb2RlSW1hZ2UgPSBmdW5jdGlvbihkYXRhLCB3LCBoLCBvdXQpXG57XG5cdHZhciBhcmVhID0gdypoLCBicHAgPSBVUE5HLmRlY29kZS5fZ2V0QlBQKG91dCk7XG5cdHZhciBicGwgPSBNYXRoLmNlaWwodypicHAvOCk7XHQvLyBieXRlcyBwZXIgbGluZVxuXG5cdHZhciBiZiA9IG5ldyBVaW50OEFycmF5KGFyZWEqNCksIGJmMzIgPSBuZXcgVWludDMyQXJyYXkoYmYuYnVmZmVyKTtcblx0dmFyIGN0eXBlID0gb3V0LmN0eXBlLCBkZXB0aCA9IG91dC5kZXB0aDtcblx0dmFyIHJzID0gVVBORy5fYmluLnJlYWRVc2hvcnQ7XG5cdFxuXHQvL2NvbnNvbGUubG9nKGN0eXBlLCBkZXB0aCk7XG5cdHZhciB0aW1lID0gRGF0ZS5ub3coKTtcblxuXHRpZiAgICAgKGN0eXBlPT02KSB7IC8vIFJHQiArIGFscGhhXG5cdFx0dmFyIHFhcmVhID0gYXJlYTw8Mjtcblx0XHRpZihkZXB0aD09IDgpIGZvcih2YXIgaT0wOyBpPHFhcmVhO2krPTQpIHsgIGJmW2ldID0gZGF0YVtpXTsgIGJmW2krMV0gPSBkYXRhW2krMV07ICBiZltpKzJdID0gZGF0YVtpKzJdOyAgYmZbaSszXSA9IGRhdGFbaSszXTsgfVxuXHRcdGlmKGRlcHRoPT0xNikgZm9yKHZhciBpPTA7IGk8cWFyZWE7aSsrICkgeyAgYmZbaV0gPSBkYXRhW2k8PDFdOyAgfVxuXHR9XG5cdGVsc2UgaWYoY3R5cGU9PTIpIHtcdC8vIFJHQlxuXHRcdHZhciB0cz1vdXQudGFic1tcInRSTlNcIl07XG5cdFx0aWYodHM9PW51bGwpIHtcblx0XHRcdGlmKGRlcHRoPT0gOCkgZm9yKHZhciBpPTA7IGk8YXJlYTsgaSsrKSB7ICB2YXIgdGk9aSozOyAgYmYzMltpXSA9ICgyNTU8PDI0KXwoZGF0YVt0aSsyXTw8MTYpfChkYXRhW3RpKzFdPDw4KXxkYXRhW3RpXTsgIH1cblx0XHRcdGlmKGRlcHRoPT0xNikgZm9yKHZhciBpPTA7IGk8YXJlYTsgaSsrKSB7ICB2YXIgdGk9aSo2OyAgYmYzMltpXSA9ICgyNTU8PDI0KXwoZGF0YVt0aSs0XTw8MTYpfChkYXRhW3RpKzJdPDw4KXxkYXRhW3RpXTsgIH1cblx0XHR9XG5cdFx0ZWxzZSB7ICB2YXIgdHI9dHNbMF0sIHRnPXRzWzFdLCB0Yj10c1syXTtcblx0XHRcdGlmKGRlcHRoPT0gOCkgZm9yKHZhciBpPTA7IGk8YXJlYTsgaSsrKSB7ICB2YXIgcWk9aTw8MiwgdGk9aSozOyAgYmYzMltpXSA9ICgyNTU8PDI0KXwoZGF0YVt0aSsyXTw8MTYpfChkYXRhW3RpKzFdPDw4KXxkYXRhW3RpXTtcblx0XHRcdFx0aWYoZGF0YVt0aV0gICA9PXRyICYmIGRhdGFbdGkrMV0gICA9PXRnICYmIGRhdGFbdGkrMl0gICA9PXRiKSBiZltxaSszXSA9IDA7ICB9XG5cdFx0XHRpZihkZXB0aD09MTYpIGZvcih2YXIgaT0wOyBpPGFyZWE7IGkrKykgeyAgdmFyIHFpPWk8PDIsIHRpPWkqNjsgIGJmMzJbaV0gPSAoMjU1PDwyNCl8KGRhdGFbdGkrNF08PDE2KXwoZGF0YVt0aSsyXTw8OCl8ZGF0YVt0aV07XG5cdFx0XHRcdGlmKHJzKGRhdGEsdGkpPT10ciAmJiBycyhkYXRhLHRpKzIpPT10ZyAmJiBycyhkYXRhLHRpKzQpPT10YikgYmZbcWkrM10gPSAwOyAgfVxuXHRcdH1cblx0fVxuXHRlbHNlIGlmKGN0eXBlPT0zKSB7XHQvLyBwYWxldHRlXG5cdFx0dmFyIHA9b3V0LnRhYnNbXCJQTFRFXCJdLCBhcD1vdXQudGFic1tcInRSTlNcIl0sIHRsPWFwP2FwLmxlbmd0aDowO1xuXHRcdC8vY29uc29sZS5sb2cocCwgYXApO1xuXHRcdGlmKGRlcHRoPT0xKSBmb3IodmFyIHk9MDsgeTxoOyB5KyspIHsgIHZhciBzMCA9IHkqYnBsLCB0MCA9IHkqdztcblx0XHRcdGZvcih2YXIgaT0wOyBpPHc7IGkrKykgeyB2YXIgcWk9KHQwK2kpPDwyLCBqPSgoZGF0YVtzMCsoaT4+MyldPj4oNy0oKGkmNyk8PDApKSkmIDEpLCBjaj0zKmo7ICBiZltxaV09cFtjal07ICBiZltxaSsxXT1wW2NqKzFdOyAgYmZbcWkrMl09cFtjaisyXTsgIGJmW3FpKzNdPShqPHRsKT9hcFtqXToyNTU7ICB9XG5cdFx0fVxuXHRcdGlmKGRlcHRoPT0yKSBmb3IodmFyIHk9MDsgeTxoOyB5KyspIHsgIHZhciBzMCA9IHkqYnBsLCB0MCA9IHkqdztcblx0XHRcdGZvcih2YXIgaT0wOyBpPHc7IGkrKykgeyB2YXIgcWk9KHQwK2kpPDwyLCBqPSgoZGF0YVtzMCsoaT4+MildPj4oNi0oKGkmMyk8PDEpKSkmIDMpLCBjaj0zKmo7ICBiZltxaV09cFtjal07ICBiZltxaSsxXT1wW2NqKzFdOyAgYmZbcWkrMl09cFtjaisyXTsgIGJmW3FpKzNdPShqPHRsKT9hcFtqXToyNTU7ICB9XG5cdFx0fVxuXHRcdGlmKGRlcHRoPT00KSBmb3IodmFyIHk9MDsgeTxoOyB5KyspIHsgIHZhciBzMCA9IHkqYnBsLCB0MCA9IHkqdztcblx0XHRcdGZvcih2YXIgaT0wOyBpPHc7IGkrKykgeyB2YXIgcWk9KHQwK2kpPDwyLCBqPSgoZGF0YVtzMCsoaT4+MSldPj4oNC0oKGkmMSk8PDIpKSkmMTUpLCBjaj0zKmo7ICBiZltxaV09cFtjal07ICBiZltxaSsxXT1wW2NqKzFdOyAgYmZbcWkrMl09cFtjaisyXTsgIGJmW3FpKzNdPShqPHRsKT9hcFtqXToyNTU7ICB9XG5cdFx0fVxuXHRcdGlmKGRlcHRoPT04KSBmb3IodmFyIGk9MDsgaTxhcmVhOyBpKysgKSB7ICB2YXIgcWk9aTw8Miwgaj1kYXRhW2ldICAgICAgICAgICAgICAgICAgICAgICwgY2o9MypqOyAgYmZbcWldPXBbY2pdOyAgYmZbcWkrMV09cFtjaisxXTsgIGJmW3FpKzJdPXBbY2orMl07ICBiZltxaSszXT0oajx0bCk/YXBbal06MjU1OyAgfVxuXHR9XG5cdGVsc2UgaWYoY3R5cGU9PTQpIHtcdC8vIGdyYXkgKyBhbHBoYVxuXHRcdGlmKGRlcHRoPT0gOCkgIGZvcih2YXIgaT0wOyBpPGFyZWE7IGkrKykgeyAgdmFyIHFpPWk8PDIsIGRpPWk8PDEsIGdyPWRhdGFbZGldOyAgYmZbcWldPWdyOyAgYmZbcWkrMV09Z3I7ICBiZltxaSsyXT1ncjsgIGJmW3FpKzNdPWRhdGFbZGkrMV07ICB9XG5cdFx0aWYoZGVwdGg9PTE2KSAgZm9yKHZhciBpPTA7IGk8YXJlYTsgaSsrKSB7ICB2YXIgcWk9aTw8MiwgZGk9aTw8MiwgZ3I9ZGF0YVtkaV07ICBiZltxaV09Z3I7ICBiZltxaSsxXT1ncjsgIGJmW3FpKzJdPWdyOyAgYmZbcWkrM109ZGF0YVtkaSsyXTsgIH1cblx0fVxuXHRlbHNlIGlmKGN0eXBlPT0wKSB7XHQvLyBncmF5XG5cdFx0dmFyIHRyID0gb3V0LnRhYnNbXCJ0Uk5TXCJdID8gb3V0LnRhYnNbXCJ0Uk5TXCJdIDogLTE7XG5cdFx0Zm9yKHZhciB5PTA7IHk8aDsgeSsrKSB7XG5cdFx0XHR2YXIgb2ZmID0geSpicGwsIHRvID0geSp3O1xuXHRcdFx0aWYgICAgIChkZXB0aD09IDEpIGZvcih2YXIgeD0wOyB4PHc7IHgrKykgeyAgdmFyIGdyPTI1NSooKGRhdGFbb2ZmKyh4Pj4+MyldPj4+KDcgLSgoeCY3KSAgICkpKSYgMSksIGFsPShncj09dHIqMjU1KT8wOjI1NTsgIGJmMzJbdG8reF09KGFsPDwyNCl8KGdyPDwxNil8KGdyPDw4KXxncjsgIH1cblx0XHRcdGVsc2UgaWYoZGVwdGg9PSAyKSBmb3IodmFyIHg9MDsgeDx3OyB4KyspIHsgIHZhciBncj0gODUqKChkYXRhW29mZisoeD4+PjIpXT4+Pig2IC0oKHgmMyk8PDEpKSkmIDMpLCBhbD0oZ3I9PXRyKiA4NSk/MDoyNTU7ICBiZjMyW3RvK3hdPShhbDw8MjQpfChncjw8MTYpfChncjw8OCl8Z3I7ICB9XG5cdFx0XHRlbHNlIGlmKGRlcHRoPT0gNCkgZm9yKHZhciB4PTA7IHg8dzsgeCsrKSB7ICB2YXIgZ3I9IDE3KigoZGF0YVtvZmYrKHg+Pj4xKV0+Pj4oNCAtKCh4JjEpPDwyKSkpJjE1KSwgYWw9KGdyPT10ciogMTcpPzA6MjU1OyAgYmYzMlt0byt4XT0oYWw8PDI0KXwoZ3I8PDE2KXwoZ3I8PDgpfGdyOyAgfVxuXHRcdFx0ZWxzZSBpZihkZXB0aD09IDgpIGZvcih2YXIgeD0wOyB4PHc7IHgrKykgeyAgdmFyIGdyPWRhdGFbb2ZmKyAgICAgeF0sIGFsPShnciAgICAgICAgICAgICAgICAgPT10cik/MDoyNTU7ICBiZjMyW3RvK3hdPShhbDw8MjQpfChncjw8MTYpfChncjw8OCl8Z3I7ICB9XG5cdFx0XHRlbHNlIGlmKGRlcHRoPT0xNikgZm9yKHZhciB4PTA7IHg8dzsgeCsrKSB7ICB2YXIgZ3I9ZGF0YVtvZmYrKHg8PDEpXSwgYWw9KHJzKGRhdGEsb2ZmKyh4PDxpKSk9PXRyKT8wOjI1NTsgIGJmMzJbdG8reF09KGFsPDwyNCl8KGdyPDwxNil8KGdyPDw4KXxncjsgIH1cblx0XHR9XG5cdH1cblx0Ly9jb25zb2xlLmxvZyhEYXRlLm5vdygpLXRpbWUpO1xuXHRyZXR1cm4gYmY7XG59XG5cblxuXG5VUE5HLmRlY29kZSA9IGZ1bmN0aW9uKGJ1ZmYpXG57XG5cdHZhciBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoYnVmZiksIG9mZnNldCA9IDgsIGJpbiA9IFVQTkcuX2JpbiwgclVzID0gYmluLnJlYWRVc2hvcnQsIHJVaSA9IGJpbi5yZWFkVWludDtcblx0dmFyIG91dCA9IHt0YWJzOnt9LCBmcmFtZXM6W119O1xuXHR2YXIgZGQgPSBuZXcgVWludDhBcnJheShkYXRhLmxlbmd0aCksIGRvZmYgPSAwO1x0IC8vIHB1dCBhbGwgSURBVCBkYXRhIGludG8gaXRcblx0dmFyIGZkLCBmb2ZmID0gMDtcdC8vIGZyYW1lc1xuXHRcblx0dmFyIG1nY2sgPSBbMHg4OSwgMHg1MCwgMHg0ZSwgMHg0NywgMHgwZCwgMHgwYSwgMHgxYSwgMHgwYV07XG5cdGZvcih2YXIgaT0wOyBpPDg7IGkrKykgaWYoZGF0YVtpXSE9bWdja1tpXSkgdGhyb3cgXCJUaGUgaW5wdXQgaXMgbm90IGEgUE5HIGZpbGUhXCI7XG5cblx0d2hpbGUob2Zmc2V0PGRhdGEubGVuZ3RoKVxuXHR7XG5cdFx0dmFyIGxlbiAgPSBiaW4ucmVhZFVpbnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSA0O1xuXHRcdHZhciB0eXBlID0gYmluLnJlYWRBU0NJSShkYXRhLCBvZmZzZXQsIDQpOyAgb2Zmc2V0ICs9IDQ7XG5cdFx0Ly9jb25zb2xlLmxvZyh0eXBlLGxlbik7XG5cdFx0XG5cdFx0aWYgICAgICh0eXBlPT1cIklIRFJcIikgIHsgIFVQTkcuZGVjb2RlLl9JSERSKGRhdGEsIG9mZnNldCwgb3V0KTsgIH1cblx0XHRlbHNlIGlmKHR5cGU9PVwiSURBVFwiKSB7XG5cdFx0XHRmb3IodmFyIGk9MDsgaTxsZW47IGkrKykgZGRbZG9mZitpXSA9IGRhdGFbb2Zmc2V0K2ldO1xuXHRcdFx0ZG9mZiArPSBsZW47XG5cdFx0fVxuXHRcdGVsc2UgaWYodHlwZT09XCJhY1RMXCIpICB7XG5cdFx0XHRvdXQudGFic1t0eXBlXSA9IHsgIG51bV9mcmFtZXM6clVpKGRhdGEsIG9mZnNldCksIG51bV9wbGF5czpyVWkoZGF0YSwgb2Zmc2V0KzQpICB9O1xuXHRcdFx0ZmQgPSBuZXcgVWludDhBcnJheShkYXRhLmxlbmd0aCk7XG5cdFx0fVxuXHRcdGVsc2UgaWYodHlwZT09XCJmY1RMXCIpICB7XG5cdFx0XHRpZihmb2ZmIT0wKSB7ICB2YXIgZnIgPSBvdXQuZnJhbWVzW291dC5mcmFtZXMubGVuZ3RoLTFdO1xuXHRcdFx0XHRmci5kYXRhID0gVVBORy5kZWNvZGUuX2RlY29tcHJlc3Mob3V0LCBmZC5zbGljZSgwLGZvZmYpLCBmci5yZWN0LndpZHRoLCBmci5yZWN0LmhlaWdodCk7ICBmb2ZmPTA7XG5cdFx0XHR9XG5cdFx0XHR2YXIgcmN0ID0ge3g6clVpKGRhdGEsIG9mZnNldCsxMikseTpyVWkoZGF0YSwgb2Zmc2V0KzE2KSx3aWR0aDpyVWkoZGF0YSwgb2Zmc2V0KzQpLGhlaWdodDpyVWkoZGF0YSwgb2Zmc2V0KzgpfTtcblx0XHRcdHZhciBkZWwgPSByVXMoZGF0YSwgb2Zmc2V0KzIyKTsgIGRlbCA9IHJVcyhkYXRhLCBvZmZzZXQrMjApIC8gKGRlbD09MD8xMDA6ZGVsKTtcblx0XHRcdHZhciBmcm0gPSB7cmVjdDpyY3QsIGRlbGF5Ok1hdGgucm91bmQoZGVsKjEwMDApLCBkaXNwb3NlOmRhdGFbb2Zmc2V0KzI0XSwgYmxlbmQ6ZGF0YVtvZmZzZXQrMjVdfTtcblx0XHRcdC8vY29uc29sZS5sb2coZnJtKTtcblx0XHRcdG91dC5mcmFtZXMucHVzaChmcm0pO1xuXHRcdH1cblx0XHRlbHNlIGlmKHR5cGU9PVwiZmRBVFwiKSB7XG5cdFx0XHRmb3IodmFyIGk9MDsgaTxsZW4tNDsgaSsrKSBmZFtmb2ZmK2ldID0gZGF0YVtvZmZzZXQraSs0XTtcblx0XHRcdGZvZmYgKz0gbGVuLTQ7XG5cdFx0fVxuXHRcdGVsc2UgaWYodHlwZT09XCJwSFlzXCIpIHtcblx0XHRcdG91dC50YWJzW3R5cGVdID0gW2Jpbi5yZWFkVWludChkYXRhLCBvZmZzZXQpLCBiaW4ucmVhZFVpbnQoZGF0YSwgb2Zmc2V0KzQpLCBkYXRhW29mZnNldCs4XV07XG5cdFx0fVxuXHRcdGVsc2UgaWYodHlwZT09XCJjSFJNXCIpIHtcblx0XHRcdG91dC50YWJzW3R5cGVdID0gW107XG5cdFx0XHRmb3IodmFyIGk9MDsgaTw4OyBpKyspIG91dC50YWJzW3R5cGVdLnB1c2goYmluLnJlYWRVaW50KGRhdGEsIG9mZnNldCtpKjQpKTtcblx0XHR9XG5cdFx0ZWxzZSBpZih0eXBlPT1cInRFWHRcIikge1xuXHRcdFx0aWYob3V0LnRhYnNbdHlwZV09PW51bGwpIG91dC50YWJzW3R5cGVdID0ge307XG5cdFx0XHR2YXIgbnogPSBiaW4ubmV4dFplcm8oZGF0YSwgb2Zmc2V0KTtcblx0XHRcdHZhciBrZXl3ID0gYmluLnJlYWRBU0NJSShkYXRhLCBvZmZzZXQsIG56LW9mZnNldCk7XG5cdFx0XHR2YXIgdGV4dCA9IGJpbi5yZWFkQVNDSUkoZGF0YSwgbnorMSwgb2Zmc2V0K2xlbi1uei0xKTtcblx0XHRcdG91dC50YWJzW3R5cGVdW2tleXddID0gdGV4dDtcblx0XHR9XG5cdFx0ZWxzZSBpZih0eXBlPT1cImlUWHRcIikge1xuXHRcdFx0aWYob3V0LnRhYnNbdHlwZV09PW51bGwpIG91dC50YWJzW3R5cGVdID0ge307XG5cdFx0XHR2YXIgbnogPSAwLCBvZmYgPSBvZmZzZXQ7XG5cdFx0XHRueiA9IGJpbi5uZXh0WmVybyhkYXRhLCBvZmYpO1xuXHRcdFx0dmFyIGtleXcgPSBiaW4ucmVhZEFTQ0lJKGRhdGEsIG9mZiwgbnotb2ZmKTsgIG9mZiA9IG56ICsgMTtcblx0XHRcdHZhciBjZmxhZyA9IGRhdGFbb2ZmXSwgY21ldGggPSBkYXRhW29mZisxXTsgIG9mZis9Mjtcblx0XHRcdG56ID0gYmluLm5leHRaZXJvKGRhdGEsIG9mZik7XG5cdFx0XHR2YXIgbHRhZyA9IGJpbi5yZWFkQVNDSUkoZGF0YSwgb2ZmLCBuei1vZmYpOyAgb2ZmID0gbnogKyAxO1xuXHRcdFx0bnogPSBiaW4ubmV4dFplcm8oZGF0YSwgb2ZmKTtcblx0XHRcdHZhciB0a2V5dyA9IGJpbi5yZWFkVVRGOChkYXRhLCBvZmYsIG56LW9mZik7ICBvZmYgPSBueiArIDE7XG5cdFx0XHR2YXIgdGV4dCAgPSBiaW4ucmVhZFVURjgoZGF0YSwgb2ZmLCBsZW4tKG9mZi1vZmZzZXQpKTtcblx0XHRcdG91dC50YWJzW3R5cGVdW2tleXddID0gdGV4dDtcblx0XHR9XG5cdFx0ZWxzZSBpZih0eXBlPT1cIlBMVEVcIikge1xuXHRcdFx0b3V0LnRhYnNbdHlwZV0gPSBiaW4ucmVhZEJ5dGVzKGRhdGEsIG9mZnNldCwgbGVuKTtcblx0XHR9XG5cdFx0ZWxzZSBpZih0eXBlPT1cImhJU1RcIikge1xuXHRcdFx0dmFyIHBsID0gb3V0LnRhYnNbXCJQTFRFXCJdLmxlbmd0aC8zO1xuXHRcdFx0b3V0LnRhYnNbdHlwZV0gPSBbXTsgIGZvcih2YXIgaT0wOyBpPHBsOyBpKyspIG91dC50YWJzW3R5cGVdLnB1c2goclVzKGRhdGEsIG9mZnNldCtpKjIpKTtcblx0XHR9XG5cdFx0ZWxzZSBpZih0eXBlPT1cInRSTlNcIikge1xuXHRcdFx0aWYgICAgIChvdXQuY3R5cGU9PTMpIG91dC50YWJzW3R5cGVdID0gYmluLnJlYWRCeXRlcyhkYXRhLCBvZmZzZXQsIGxlbik7XG5cdFx0XHRlbHNlIGlmKG91dC5jdHlwZT09MCkgb3V0LnRhYnNbdHlwZV0gPSByVXMoZGF0YSwgb2Zmc2V0KTtcblx0XHRcdGVsc2UgaWYob3V0LmN0eXBlPT0yKSBvdXQudGFic1t0eXBlXSA9IFsgclVzKGRhdGEsb2Zmc2V0KSxyVXMoZGF0YSxvZmZzZXQrMiksclVzKGRhdGEsb2Zmc2V0KzQpIF07XG5cdFx0XHQvL2Vsc2UgY29uc29sZS5sb2coXCJ0Uk5TIGZvciB1bnN1cHBvcnRlZCBjb2xvciB0eXBlXCIsb3V0LmN0eXBlLCBsZW4pO1xuXHRcdH1cblx0XHRlbHNlIGlmKHR5cGU9PVwiZ0FNQVwiKSBvdXQudGFic1t0eXBlXSA9IGJpbi5yZWFkVWludChkYXRhLCBvZmZzZXQpLzEwMDAwMDtcblx0XHRlbHNlIGlmKHR5cGU9PVwic1JHQlwiKSBvdXQudGFic1t0eXBlXSA9IGRhdGFbb2Zmc2V0XTtcblx0XHRlbHNlIGlmKHR5cGU9PVwiYktHRFwiKVxuXHRcdHtcblx0XHRcdGlmICAgICAob3V0LmN0eXBlPT0wIHx8IG91dC5jdHlwZT09NCkgb3V0LnRhYnNbdHlwZV0gPSBbclVzKGRhdGEsIG9mZnNldCldO1xuXHRcdFx0ZWxzZSBpZihvdXQuY3R5cGU9PTIgfHwgb3V0LmN0eXBlPT02KSBvdXQudGFic1t0eXBlXSA9IFtyVXMoZGF0YSwgb2Zmc2V0KSwgclVzKGRhdGEsIG9mZnNldCsyKSwgclVzKGRhdGEsIG9mZnNldCs0KV07XG5cdFx0XHRlbHNlIGlmKG91dC5jdHlwZT09Mykgb3V0LnRhYnNbdHlwZV0gPSBkYXRhW29mZnNldF07XG5cdFx0fVxuXHRcdGVsc2UgaWYodHlwZT09XCJJRU5EXCIpIHtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0XHQvL2Vsc2UgeyAgbG9nKFwidW5rbm93biBjaHVuayB0eXBlXCIsIHR5cGUsIGxlbik7ICB9XG5cdFx0b2Zmc2V0ICs9IGxlbjtcblx0XHR2YXIgY3JjID0gYmluLnJlYWRVaW50KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gNDtcblx0fVxuXHRpZihmb2ZmIT0wKSB7ICB2YXIgZnIgPSBvdXQuZnJhbWVzW291dC5mcmFtZXMubGVuZ3RoLTFdO1xuXHRcdGZyLmRhdGEgPSBVUE5HLmRlY29kZS5fZGVjb21wcmVzcyhvdXQsIGZkLnNsaWNlKDAsZm9mZiksIGZyLnJlY3Qud2lkdGgsIGZyLnJlY3QuaGVpZ2h0KTsgIGZvZmY9MDtcblx0fVx0XG5cdG91dC5kYXRhID0gVVBORy5kZWNvZGUuX2RlY29tcHJlc3Mob3V0LCBkZCwgb3V0LndpZHRoLCBvdXQuaGVpZ2h0KTtcblx0XG5cdGRlbGV0ZSBvdXQuY29tcHJlc3M7ICBkZWxldGUgb3V0LmludGVybGFjZTsgIGRlbGV0ZSBvdXQuZmlsdGVyO1xuXHRyZXR1cm4gb3V0O1xufVxuXG5VUE5HLmRlY29kZS5fZGVjb21wcmVzcyA9IGZ1bmN0aW9uKG91dCwgZGQsIHcsIGgpIHtcblx0dmFyIHRpbWUgPSBEYXRlLm5vdygpO1xuXHR2YXIgYnBwID0gVVBORy5kZWNvZGUuX2dldEJQUChvdXQpLCBicGwgPSBNYXRoLmNlaWwodypicHAvOCksIGJ1ZmYgPSBuZXcgVWludDhBcnJheSgoYnBsKzErb3V0LmludGVybGFjZSkqaCk7XG5cdGRkID0gVVBORy5kZWNvZGUuX2luZmxhdGUoZGQsYnVmZik7XG5cdC8vY29uc29sZS5sb2coZGQubGVuZ3RoLCBidWZmLmxlbmd0aCk7XG5cdC8vY29uc29sZS5sb2coRGF0ZS5ub3coKS10aW1lKTtcblxuXHR2YXIgdGltZT1EYXRlLm5vdygpO1xuXHRpZiAgICAgKG91dC5pbnRlcmxhY2U9PTApIGRkID0gVVBORy5kZWNvZGUuX2ZpbHRlclplcm8oZGQsIG91dCwgMCwgdywgaCk7XG5cdGVsc2UgaWYob3V0LmludGVybGFjZT09MSkgZGQgPSBVUE5HLmRlY29kZS5fcmVhZEludGVybGFjZShkZCwgb3V0KTtcblx0Ly9jb25zb2xlLmxvZyhEYXRlLm5vdygpLXRpbWUpO1xuXHRyZXR1cm4gZGQ7XG59XG5cblVQTkcuZGVjb2RlLl9pbmZsYXRlID0gZnVuY3Rpb24oZGF0YSwgYnVmZikgeyAgdmFyIG91dD1VUE5HW1wiaW5mbGF0ZVJhd1wiXShuZXcgVWludDhBcnJheShkYXRhLmJ1ZmZlciwgMixkYXRhLmxlbmd0aC02KSxidWZmKTsgIHJldHVybiBvdXQ7ICB9XG5VUE5HLmluZmxhdGVSYXc9ZnVuY3Rpb24oKXt2YXIgSD17fTtILkg9e307SC5ILk49ZnVuY3Rpb24oTixXKXt2YXIgUj1VaW50OEFycmF5LGk9MCxtPTAsSj0wLGg9MCxRPTAsWD0wLHU9MCx3PTAsZD0wLHYsQztcbmlmKE5bMF09PTMmJk5bMV09PTApcmV0dXJuIFc/VzpuZXcgUigwKTt2YXIgVj1ILkgsbj1WLmIsQT1WLmUsbD1WLlIsTT1WLm4sST1WLkEsZT1WLlosYj1WLm0sWj1XPT1udWxsO1xuaWYoWilXPW5ldyBSKE4ubGVuZ3RoPj4+Mjw8Myk7d2hpbGUoaT09MCl7aT1uKE4sZCwxKTttPW4oTixkKzEsMik7ZCs9MztpZihtPT0wKXtpZigoZCY3KSE9MClkKz04LShkJjcpO1xudmFyIEQ9KGQ+Pj4zKSs0LHE9TltELTRdfE5bRC0zXTw8ODtpZihaKVc9SC5ILlcoVyx3K3EpO1cuc2V0KG5ldyBSKE4uYnVmZmVyLE4uYnl0ZU9mZnNldCtELHEpLHcpO2Q9RCtxPDwzO1xudys9cTtjb250aW51ZX1pZihaKVc9SC5ILlcoVyx3KygxPDwxNykpO2lmKG09PTEpe3Y9Yi5KO0M9Yi5oO1g9KDE8PDkpLTE7dT0oMTw8NSktMX1pZihtPT0yKXtKPUEoTixkLDUpKzI1Nztcbmg9QShOLGQrNSw1KSsxO1E9QShOLGQrMTAsNCkrNDtkKz0xNDt2YXIgRT1kLGo9MTtmb3IodmFyIGM9MDtjPDM4O2MrPTIpe2IuUVtjXT0wO2IuUVtjKzFdPTB9Zm9yKHZhciBjPTA7XG5jPFE7YysrKXt2YXIgSz1BKE4sZCtjKjMsMyk7Yi5RWyhiLlhbY108PDEpKzFdPUs7aWYoSz5qKWo9S31kKz0zKlE7TShiLlEsaik7SShiLlEsaixiLnUpO3Y9Yi53O0M9Yi5kO1xuZD1sKGIudSwoMTw8aiktMSxKK2gsTixkLGIudik7dmFyIHI9Vi5WKGIudiwwLEosYi5DKTtYPSgxPDxyKS0xO3ZhciBTPVYuVihiLnYsSixoLGIuRCk7dT0oMTw8UyktMTtNKGIuQyxyKTtcbkkoYi5DLHIsdik7TShiLkQsUyk7SShiLkQsUyxDKX13aGlsZSghMCl7dmFyIFQ9dltlKE4sZCkmWF07ZCs9VCYxNTt2YXIgcD1UPj4+NDtpZihwPj4+OD09MCl7V1t3KytdPXB9ZWxzZSBpZihwPT0yNTYpe2JyZWFrfWVsc2V7dmFyIHo9dytwLTI1NDtcbmlmKHA+MjY0KXt2YXIgXz1iLnFbcC0yNTddO3o9dysoXz4+PjMpK0EoTixkLF8mNyk7ZCs9XyY3fXZhciAkPUNbZShOLGQpJnVdO2QrPSQmMTU7dmFyIHM9JD4+PjQsWT1iLmNbc10sYT0oWT4+PjQpK24oTixkLFkmMTUpO1xuZCs9WSYxNTt3aGlsZSh3PHope1dbd109V1t3KystYV07V1t3XT1XW3crKy1hXTtXW3ddPVdbdysrLWFdO1dbd109V1t3KystYV19dz16fX19cmV0dXJuIFcubGVuZ3RoPT13P1c6Vy5zbGljZSgwLHcpfTtcbkguSC5XPWZ1bmN0aW9uKE4sVyl7dmFyIFI9Ti5sZW5ndGg7aWYoVzw9UilyZXR1cm4gTjt2YXIgVj1uZXcgVWludDhBcnJheShSPDwxKTtWLnNldChOLDApO3JldHVybiBWfTtcbkguSC5SPWZ1bmN0aW9uKE4sVyxSLFYsbixBKXt2YXIgbD1ILkguZSxNPUguSC5aLEk9MDt3aGlsZShJPFIpe3ZhciBlPU5bTShWLG4pJlddO24rPWUmMTU7dmFyIGI9ZT4+PjQ7XG5pZihiPD0xNSl7QVtJXT1iO0krK31lbHNle3ZhciBaPTAsbT0wO2lmKGI9PTE2KXttPTMrbChWLG4sMik7bis9MjtaPUFbSS0xXX1lbHNlIGlmKGI9PTE3KXttPTMrbChWLG4sMyk7XG5uKz0zfWVsc2UgaWYoYj09MTgpe209MTErbChWLG4sNyk7bis9N312YXIgSj1JK207d2hpbGUoSTxKKXtBW0ldPVo7SSsrfX19cmV0dXJuIG59O0guSC5WPWZ1bmN0aW9uKE4sVyxSLFYpe3ZhciBuPTAsQT0wLGw9Vi5sZW5ndGg+Pj4xO1xud2hpbGUoQTxSKXt2YXIgTT1OW0ErV107VltBPDwxXT0wO1ZbKEE8PDEpKzFdPU07aWYoTT5uKW49TTtBKyt9d2hpbGUoQTxsKXtWW0E8PDFdPTA7VlsoQTw8MSkrMV09MDtBKyt9cmV0dXJuIG59O1xuSC5ILm49ZnVuY3Rpb24oTixXKXt2YXIgUj1ILkgubSxWPU4ubGVuZ3RoLG4sQSxsLE0sSSxlPVIuajtmb3IodmFyIE09MDtNPD1XO00rKyllW01dPTA7Zm9yKE09MTtNPFY7TSs9MillW05bTV1dKys7XG52YXIgYj1SLks7bj0wO2VbMF09MDtmb3IoQT0xO0E8PVc7QSsrKXtuPW4rZVtBLTFdPDwxO2JbQV09bn1mb3IobD0wO2w8VjtsKz0yKXtJPU5bbCsxXTtpZihJIT0wKXtOW2xdPWJbSV07XG5iW0ldKyt9fX07SC5ILkE9ZnVuY3Rpb24oTixXLFIpe3ZhciBWPU4ubGVuZ3RoLG49SC5ILm0sQT1uLnI7Zm9yKHZhciBsPTA7bDxWO2wrPTIpaWYoTltsKzFdIT0wKXt2YXIgTT1sPj4xLEk9TltsKzFdLGU9TTw8NHxJLGI9Vy1JLFo9TltsXTw8YixtPVorKDE8PGIpO1xud2hpbGUoWiE9bSl7dmFyIEo9QVtaXT4+PjE1LVc7UltKXT1lO1orK319fTtILkgubD1mdW5jdGlvbihOLFcpe3ZhciBSPUguSC5tLnIsVj0xNS1XO2Zvcih2YXIgbj0wO248Ti5sZW5ndGg7XG5uKz0yKXt2YXIgQT1OW25dPDxXLU5bbisxXTtOW25dPVJbQV0+Pj5WfX07SC5ILk09ZnVuY3Rpb24oTixXLFIpe1I9Ujw8KFcmNyk7dmFyIFY9Vz4+PjM7TltWXXw9UjtOW1YrMV18PVI+Pj44fTtcbkguSC5JPWZ1bmN0aW9uKE4sVyxSKXtSPVI8PChXJjcpO3ZhciBWPVc+Pj4zO05bVl18PVI7TltWKzFdfD1SPj4+ODtOW1YrMl18PVI+Pj4xNn07SC5ILmU9ZnVuY3Rpb24oTixXLFIpe3JldHVybihOW1c+Pj4zXXxOWyhXPj4+MykrMV08PDgpPj4+KFcmNykmKDE8PFIpLTF9O1xuSC5ILmI9ZnVuY3Rpb24oTixXLFIpe3JldHVybihOW1c+Pj4zXXxOWyhXPj4+MykrMV08PDh8TlsoVz4+PjMpKzJdPDwxNik+Pj4oVyY3KSYoMTw8UiktMX07SC5ILlo9ZnVuY3Rpb24oTixXKXtyZXR1cm4oTltXPj4+M118TlsoVz4+PjMpKzFdPDw4fE5bKFc+Pj4zKSsyXTw8MTYpPj4+KFcmNyl9O1xuSC5ILmk9ZnVuY3Rpb24oTixXKXtyZXR1cm4oTltXPj4+M118TlsoVz4+PjMpKzFdPDw4fE5bKFc+Pj4zKSsyXTw8MTZ8TlsoVz4+PjMpKzNdPDwyNCk+Pj4oVyY3KX07SC5ILm09ZnVuY3Rpb24oKXt2YXIgTj1VaW50MTZBcnJheSxXPVVpbnQzMkFycmF5O1xucmV0dXJue0s6bmV3IE4oMTYpLGo6bmV3IE4oMTYpLFg6WzE2LDE3LDE4LDAsOCw3LDksNiwxMCw1LDExLDQsMTIsMywxMywyLDE0LDEsMTVdLFM6WzMsNCw1LDYsNyw4LDksMTAsMTEsMTMsMTUsMTcsMTksMjMsMjcsMzEsMzUsNDMsNTEsNTksNjcsODMsOTksMTE1LDEzMSwxNjMsMTk1LDIyNywyNTgsOTk5LDk5OSw5OTldLFQ6WzAsMCwwLDAsMCwwLDAsMCwxLDEsMSwxLDIsMiwyLDIsMywzLDMsMyw0LDQsNCw0LDUsNSw1LDUsMCwwLDAsMF0scTpuZXcgTigzMikscDpbMSwyLDMsNCw1LDcsOSwxMywxNywyNSwzMyw0OSw2NSw5NywxMjksMTkzLDI1NywzODUsNTEzLDc2OSwxMDI1LDE1MzcsMjA0OSwzMDczLDQwOTcsNjE0NSw4MTkzLDEyMjg5LDE2Mzg1LDI0NTc3LDY1NTM1LDY1NTM1XSx6OlswLDAsMCwwLDEsMSwyLDIsMywzLDQsNCw1LDUsNiw2LDcsNyw4LDgsOSw5LDEwLDEwLDExLDExLDEyLDEyLDEzLDEzLDAsMF0sYzpuZXcgVygzMiksSjpuZXcgTig1MTIpLF86W10saDpuZXcgTigzMiksJDpbXSx3Om5ldyBOKDMyNzY4KSxDOltdLHY6W10sZDpuZXcgTigzMjc2OCksRDpbXSx1Om5ldyBOKDUxMiksUTpbXSxyOm5ldyBOKDE8PDE1KSxzOm5ldyBXKDI4NiksWTpuZXcgVygzMCksYTpuZXcgVygxOSksdDpuZXcgVygxNWUzKSxrOm5ldyBOKDE8PDE2KSxnOm5ldyBOKDE8PDE1KX19KCk7XG4oZnVuY3Rpb24oKXt2YXIgTj1ILkgubSxXPTE8PDE1O2Zvcih2YXIgUj0wO1I8VztSKyspe3ZhciBWPVI7Vj0oViYyODYzMzExNTMwKT4+PjF8KFYmMTQzMTY1NTc2NSk8PDE7XG5WPShWJjM0MzU5NzM4MzYpPj4+MnwoViY4NTg5OTM0NTkpPDwyO1Y9KFYmNDA0MjMyMjE2MCk+Pj40fChWJjI1MjY0NTEzNSk8PDQ7Vj0oViY0Mjc4MjU1MzYwKT4+Pjh8KFYmMTY3MTE5MzUpPDw4O1xuTi5yW1JdPShWPj4+MTZ8Vjw8MTYpPj4+MTd9ZnVuY3Rpb24gbihBLGwsTSl7d2hpbGUobC0tIT0wKUEucHVzaCgwLE0pfWZvcih2YXIgUj0wO1I8MzI7UisrKXtOLnFbUl09Ti5TW1JdPDwzfE4uVFtSXTtcbk4uY1tSXT1OLnBbUl08PDR8Ti56W1JdfW4oTi5fLDE0NCw4KTtuKE4uXywyNTUtMTQzLDkpO24oTi5fLDI3OS0yNTUsNyk7bihOLl8sMjg3LTI3OSw4KTtILkgubihOLl8sOSk7XG5ILkguQShOLl8sOSxOLkopO0guSC5sKE4uXyw5KTtuKE4uJCwzMiw1KTtILkgubihOLiQsNSk7SC5ILkEoTi4kLDUsTi5oKTtILkgubChOLiQsNSk7bihOLlEsMTksMCk7bihOLkMsMjg2LDApO1xubihOLkQsMzAsMCk7bihOLnYsMzIwLDApfSgpKTtyZXR1cm4gSC5ILk59KClcblxuXG5VUE5HLmRlY29kZS5fcmVhZEludGVybGFjZSA9IGZ1bmN0aW9uKGRhdGEsIG91dClcbntcblx0dmFyIHcgPSBvdXQud2lkdGgsIGggPSBvdXQuaGVpZ2h0O1xuXHR2YXIgYnBwID0gVVBORy5kZWNvZGUuX2dldEJQUChvdXQpLCBjYnBwID0gYnBwPj4zLCBicGwgPSBNYXRoLmNlaWwodypicHAvOCk7XG5cdHZhciBpbWcgPSBuZXcgVWludDhBcnJheSggaCAqIGJwbCApO1xuXHR2YXIgZGkgPSAwO1xuXG5cdHZhciBzdGFydGluZ19yb3cgID0gWyAwLCAwLCA0LCAwLCAyLCAwLCAxIF07XG5cdHZhciBzdGFydGluZ19jb2wgID0gWyAwLCA0LCAwLCAyLCAwLCAxLCAwIF07XG5cdHZhciByb3dfaW5jcmVtZW50ID0gWyA4LCA4LCA4LCA0LCA0LCAyLCAyIF07XG5cdHZhciBjb2xfaW5jcmVtZW50ID0gWyA4LCA4LCA0LCA0LCAyLCAyLCAxIF07XG5cblx0dmFyIHBhc3M9MDtcblx0d2hpbGUocGFzczw3KVxuXHR7XG5cdFx0dmFyIHJpID0gcm93X2luY3JlbWVudFtwYXNzXSwgY2kgPSBjb2xfaW5jcmVtZW50W3Bhc3NdO1xuXHRcdHZhciBzdyA9IDAsIHNoID0gMDtcblx0XHR2YXIgY3IgPSBzdGFydGluZ19yb3dbcGFzc107ICB3aGlsZShjcjxoKSB7ICBjcis9cmk7ICBzaCsrOyAgfVxuXHRcdHZhciBjYyA9IHN0YXJ0aW5nX2NvbFtwYXNzXTsgIHdoaWxlKGNjPHcpIHsgIGNjKz1jaTsgIHN3Kys7ICB9XG5cdFx0dmFyIGJwbGwgPSBNYXRoLmNlaWwoc3cqYnBwLzgpO1xuXHRcdFVQTkcuZGVjb2RlLl9maWx0ZXJaZXJvKGRhdGEsIG91dCwgZGksIHN3LCBzaCk7XG5cblx0XHR2YXIgeT0wLCByb3cgPSBzdGFydGluZ19yb3dbcGFzc107XG5cdFx0d2hpbGUocm93PGgpXG5cdFx0e1xuXHRcdFx0dmFyIGNvbCA9IHN0YXJ0aW5nX2NvbFtwYXNzXTtcblx0XHRcdHZhciBjZGkgPSAoZGkreSpicGxsKTw8MztcblxuXHRcdFx0d2hpbGUoY29sPHcpXG5cdFx0XHR7XG5cdFx0XHRcdGlmKGJwcD09MSkge1xuXHRcdFx0XHRcdHZhciB2YWwgPSBkYXRhW2NkaT4+M107ICB2YWwgPSAodmFsPj4oNy0oY2RpJjcpKSkmMTtcblx0XHRcdFx0XHRpbWdbcm93KmJwbCArIChjb2w+PjMpXSB8PSAodmFsIDw8ICg3LSgoY29sJjcpPDwwKSkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKGJwcD09Mikge1xuXHRcdFx0XHRcdHZhciB2YWwgPSBkYXRhW2NkaT4+M107ICB2YWwgPSAodmFsPj4oNi0oY2RpJjcpKSkmMztcblx0XHRcdFx0XHRpbWdbcm93KmJwbCArIChjb2w+PjIpXSB8PSAodmFsIDw8ICg2LSgoY29sJjMpPDwxKSkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKGJwcD09NCkge1xuXHRcdFx0XHRcdHZhciB2YWwgPSBkYXRhW2NkaT4+M107ICB2YWwgPSAodmFsPj4oNC0oY2RpJjcpKSkmMTU7XG5cdFx0XHRcdFx0aW1nW3JvdypicGwgKyAoY29sPj4xKV0gfD0gKHZhbCA8PCAoNC0oKGNvbCYxKTw8MikpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZihicHA+PTgpIHtcblx0XHRcdFx0XHR2YXIgaWkgPSByb3cqYnBsK2NvbCpjYnBwO1xuXHRcdFx0XHRcdGZvcih2YXIgaj0wOyBqPGNicHA7IGorKykgaW1nW2lpK2pdID0gZGF0YVsoY2RpPj4zKStqXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjZGkrPWJwcDsgIGNvbCs9Y2k7XG5cdFx0XHR9XG5cdFx0XHR5Kys7ICByb3cgKz0gcmk7XG5cdFx0fVxuXHRcdGlmKHN3KnNoIT0wKSBkaSArPSBzaCAqICgxICsgYnBsbCk7XG5cdFx0cGFzcyA9IHBhc3MgKyAxO1xuXHR9XG5cdHJldHVybiBpbWc7XG59XG5cblVQTkcuZGVjb2RlLl9nZXRCUFAgPSBmdW5jdGlvbihvdXQpIHtcblx0dmFyIG5vYyA9IFsxLG51bGwsMywxLDIsbnVsbCw0XVtvdXQuY3R5cGVdO1xuXHRyZXR1cm4gbm9jICogb3V0LmRlcHRoO1xufVxuXG5VUE5HLmRlY29kZS5fZmlsdGVyWmVybyA9IGZ1bmN0aW9uKGRhdGEsIG91dCwgb2ZmLCB3LCBoKVxue1xuXHR2YXIgYnBwID0gVVBORy5kZWNvZGUuX2dldEJQUChvdXQpLCBicGwgPSBNYXRoLmNlaWwodypicHAvOCksIHBhZXRoID0gVVBORy5kZWNvZGUuX3BhZXRoO1xuXHRicHAgPSBNYXRoLmNlaWwoYnBwLzgpO1xuXHRcblx0dmFyIGk9MCwgZGk9MSwgdHlwZT1kYXRhW29mZl0sIHg9MDtcblx0XG5cdGlmKHR5cGU+MSkgZGF0YVtvZmZdPVswLDAsMV1bdHlwZS0yXTsgIFxuXHRpZih0eXBlPT0zKSBmb3IoeD1icHA7IHg8YnBsOyB4KyspIGRhdGFbeCsxXSA9IChkYXRhW3grMV0gKyAoZGF0YVt4KzEtYnBwXT4+PjEpICkmMjU1O1xuXG5cdGZvcih2YXIgeT0wOyB5PGg7IHkrKykgIHtcblx0XHRpID0gb2ZmK3kqYnBsOyBkaSA9IGkreSsxO1xuXHRcdHR5cGUgPSBkYXRhW2RpLTFdOyB4PTA7XG5cblx0XHRpZiAgICAgKHR5cGU9PTApICAgZm9yKDsgeDxicGw7IHgrKykgZGF0YVtpK3hdID0gZGF0YVtkaSt4XTtcblx0XHRlbHNlIGlmKHR5cGU9PTEpIHsgZm9yKDsgeDxicHA7IHgrKykgZGF0YVtpK3hdID0gZGF0YVtkaSt4XTtcblx0XHRcdFx0XHRcdCAgIGZvcig7IHg8YnBsOyB4KyspIGRhdGFbaSt4XSA9IChkYXRhW2RpK3hdICsgZGF0YVtpK3gtYnBwXSk7ICB9XG5cdFx0ZWxzZSBpZih0eXBlPT0yKSB7IGZvcig7IHg8YnBsOyB4KyspIGRhdGFbaSt4XSA9IChkYXRhW2RpK3hdICsgZGF0YVtpK3gtYnBsXSk7ICB9XG5cdFx0ZWxzZSBpZih0eXBlPT0zKSB7IGZvcig7IHg8YnBwOyB4KyspIGRhdGFbaSt4XSA9IChkYXRhW2RpK3hdICsgKCBkYXRhW2kreC1icGxdPj4+MSkpO1xuXHRcdFx0ICAgICAgICAgICAgICAgZm9yKDsgeDxicGw7IHgrKykgZGF0YVtpK3hdID0gKGRhdGFbZGkreF0gKyAoKGRhdGFbaSt4LWJwbF0rZGF0YVtpK3gtYnBwXSk+Pj4xKSApOyAgfVxuXHRcdGVsc2UgICAgICAgICAgICAgeyBmb3IoOyB4PGJwcDsgeCsrKSBkYXRhW2kreF0gPSAoZGF0YVtkaSt4XSArIHBhZXRoKDAsIGRhdGFbaSt4LWJwbF0sIDApKTtcblx0XHRcdFx0XHRcdCAgIGZvcig7IHg8YnBsOyB4KyspIGRhdGFbaSt4XSA9IChkYXRhW2RpK3hdICsgcGFldGgoZGF0YVtpK3gtYnBwXSwgZGF0YVtpK3gtYnBsXSwgZGF0YVtpK3gtYnBwLWJwbF0pICk7ICB9XG5cdH1cblx0cmV0dXJuIGRhdGE7XG59XG5cblVQTkcuZGVjb2RlLl9wYWV0aCA9IGZ1bmN0aW9uKGEsYixjKVxue1xuXHR2YXIgcCA9IGErYi1jLCBwYSA9IChwLWEpLCBwYiA9IChwLWIpLCBwYyA9IChwLWMpO1xuXHRpZiAocGEqcGEgPD0gcGIqcGIgJiYgcGEqcGEgPD0gcGMqcGMpICByZXR1cm4gYTtcblx0ZWxzZSBpZiAocGIqcGIgPD0gcGMqcGMpICByZXR1cm4gYjtcblx0cmV0dXJuIGM7XG59XG5cblVQTkcuZGVjb2RlLl9JSERSID0gZnVuY3Rpb24oZGF0YSwgb2Zmc2V0LCBvdXQpXG57XG5cdHZhciBiaW4gPSBVUE5HLl9iaW47XG5cdG91dC53aWR0aCAgPSBiaW4ucmVhZFVpbnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSA0O1xuXHRvdXQuaGVpZ2h0ID0gYmluLnJlYWRVaW50KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gNDtcblx0b3V0LmRlcHRoICAgICA9IGRhdGFbb2Zmc2V0XTsgIG9mZnNldCsrO1xuXHRvdXQuY3R5cGUgICAgID0gZGF0YVtvZmZzZXRdOyAgb2Zmc2V0Kys7XG5cdG91dC5jb21wcmVzcyAgPSBkYXRhW29mZnNldF07ICBvZmZzZXQrKztcblx0b3V0LmZpbHRlciAgICA9IGRhdGFbb2Zmc2V0XTsgIG9mZnNldCsrO1xuXHRvdXQuaW50ZXJsYWNlID0gZGF0YVtvZmZzZXRdOyAgb2Zmc2V0Kys7XG59XG5cblVQTkcuX2JpbiA9IHtcblx0bmV4dFplcm8gICA6IGZ1bmN0aW9uKGRhdGEscCkgIHsgIHdoaWxlKGRhdGFbcF0hPTApIHArKzsgIHJldHVybiBwOyAgfSxcblx0cmVhZFVzaG9ydCA6IGZ1bmN0aW9uKGJ1ZmYscCkgIHsgIHJldHVybiAoYnVmZltwXTw8IDgpIHwgYnVmZltwKzFdOyAgfSxcblx0d3JpdGVVc2hvcnQ6IGZ1bmN0aW9uKGJ1ZmYscCxuKXsgIGJ1ZmZbcF0gPSAobj4+OCkmMjU1OyAgYnVmZltwKzFdID0gbiYyNTU7ICB9LFxuXHRyZWFkVWludCAgIDogZnVuY3Rpb24oYnVmZixwKSAgeyAgcmV0dXJuIChidWZmW3BdKigyNTYqMjU2KjI1NikpICsgKChidWZmW3ArMV08PDE2KSB8IChidWZmW3ArMl08PCA4KSB8IGJ1ZmZbcCszXSk7ICB9LFxuXHR3cml0ZVVpbnQgIDogZnVuY3Rpb24oYnVmZixwLG4peyAgYnVmZltwXT0obj4+MjQpJjI1NTsgIGJ1ZmZbcCsxXT0obj4+MTYpJjI1NTsgIGJ1ZmZbcCsyXT0obj4+OCkmMjU1OyAgYnVmZltwKzNdPW4mMjU1OyAgfSxcblx0cmVhZEFTQ0lJICA6IGZ1bmN0aW9uKGJ1ZmYscCxsKXsgIHZhciBzID0gXCJcIjsgIGZvcih2YXIgaT0wOyBpPGw7IGkrKykgcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZmZbcCtpXSk7ICByZXR1cm4gczsgICAgfSxcblx0d3JpdGVBU0NJSSA6IGZ1bmN0aW9uKGRhdGEscCxzKXsgIGZvcih2YXIgaT0wOyBpPHMubGVuZ3RoOyBpKyspIGRhdGFbcCtpXSA9IHMuY2hhckNvZGVBdChpKTsgIH0sXG5cdHJlYWRCeXRlcyAgOiBmdW5jdGlvbihidWZmLHAsbCl7ICB2YXIgYXJyID0gW107ICAgZm9yKHZhciBpPTA7IGk8bDsgaSsrKSBhcnIucHVzaChidWZmW3AraV0pOyAgIHJldHVybiBhcnI7ICB9LFxuXHRwYWQgOiBmdW5jdGlvbihuKSB7IHJldHVybiBuLmxlbmd0aCA8IDIgPyBcIjBcIiArIG4gOiBuOyB9LFxuXHRyZWFkVVRGOCA6IGZ1bmN0aW9uKGJ1ZmYsIHAsIGwpIHtcblx0XHR2YXIgcyA9IFwiXCIsIG5zO1xuXHRcdGZvcih2YXIgaT0wOyBpPGw7IGkrKykgcyArPSBcIiVcIiArIFVQTkcuX2Jpbi5wYWQoYnVmZltwK2ldLnRvU3RyaW5nKDE2KSk7XG5cdFx0dHJ5IHsgIG5zID0gZGVjb2RlVVJJQ29tcG9uZW50KHMpOyB9XG5cdFx0Y2F0Y2goZSkgeyAgcmV0dXJuIFVQTkcuX2Jpbi5yZWFkQVNDSUkoYnVmZiwgcCwgbCk7ICB9XG5cdFx0cmV0dXJuICBucztcblx0fVxufVxuVVBORy5fY29weVRpbGUgPSBmdW5jdGlvbihzYiwgc3csIHNoLCB0YiwgdHcsIHRoLCB4b2ZmLCB5b2ZmLCBtb2RlKVxue1xuXHR2YXIgdyA9IE1hdGgubWluKHN3LHR3KSwgaCA9IE1hdGgubWluKHNoLHRoKTtcblx0dmFyIHNpPTAsIHRpPTA7XG5cdGZvcih2YXIgeT0wOyB5PGg7IHkrKylcblx0XHRmb3IodmFyIHg9MDsgeDx3OyB4KyspXG5cdFx0e1xuXHRcdFx0aWYoeG9mZj49MCAmJiB5b2ZmPj0wKSB7ICBzaSA9ICh5KnN3K3gpPDwyOyAgdGkgPSAoKCB5b2ZmK3kpKnR3K3hvZmYreCk8PDI7ICB9XG5cdFx0XHRlbHNlICAgICAgICAgICAgICAgICAgIHsgIHNpID0gKCgteW9mZit5KSpzdy14b2ZmK3gpPDwyOyAgdGkgPSAoeSp0dyt4KTw8MjsgIH1cblx0XHRcdFxuXHRcdFx0aWYgICAgIChtb2RlPT0wKSB7ICB0Ylt0aV0gPSBzYltzaV07ICB0Ylt0aSsxXSA9IHNiW3NpKzFdOyAgdGJbdGkrMl0gPSBzYltzaSsyXTsgIHRiW3RpKzNdID0gc2Jbc2krM107ICB9XG5cdFx0XHRlbHNlIGlmKG1vZGU9PTEpIHtcblx0XHRcdFx0dmFyIGZhID0gc2Jbc2krM10qKDEvMjU1KSwgZnI9c2Jbc2ldKmZhLCBmZz1zYltzaSsxXSpmYSwgZmI9c2Jbc2krMl0qZmE7IFxuXHRcdFx0XHR2YXIgYmEgPSB0Ylt0aSszXSooMS8yNTUpLCBicj10Ylt0aV0qYmEsIGJnPXRiW3RpKzFdKmJhLCBiYj10Ylt0aSsyXSpiYTsgXG5cdFx0XHRcdFxuXHRcdFx0XHR2YXIgaWZhPTEtZmEsIG9hID0gZmErYmEqaWZhLCBpb2EgPSAob2E9PTA/MDoxL29hKTtcblx0XHRcdFx0dGJbdGkrM10gPSAyNTUqb2E7ICBcblx0XHRcdFx0dGJbdGkrMF0gPSAoZnIrYnIqaWZhKSppb2E7ICBcblx0XHRcdFx0dGJbdGkrMV0gPSAoZmcrYmcqaWZhKSppb2E7ICAgXG5cdFx0XHRcdHRiW3RpKzJdID0gKGZiK2JiKmlmYSkqaW9hOyAgXG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmKG1vZGU9PTIpe1x0Ly8gY29weSBvbmx5IGRpZmZlcmVuY2VzLCBvdGhlcndpc2UgemVyb1xuXHRcdFx0XHR2YXIgZmEgPSBzYltzaSszXSwgZnI9c2Jbc2ldLCBmZz1zYltzaSsxXSwgZmI9c2Jbc2krMl07IFxuXHRcdFx0XHR2YXIgYmEgPSB0Ylt0aSszXSwgYnI9dGJbdGldLCBiZz10Ylt0aSsxXSwgYmI9dGJbdGkrMl07IFxuXHRcdFx0XHRpZihmYT09YmEgJiYgZnI9PWJyICYmIGZnPT1iZyAmJiBmYj09YmIpIHsgIHRiW3RpXT0wOyAgdGJbdGkrMV09MDsgIHRiW3RpKzJdPTA7ICB0Ylt0aSszXT0wOyAgfVxuXHRcdFx0XHRlbHNlIHsgIHRiW3RpXT1mcjsgIHRiW3RpKzFdPWZnOyAgdGJbdGkrMl09ZmI7ICB0Ylt0aSszXT1mYTsgIH1cblx0XHRcdH1cblx0XHRcdGVsc2UgaWYobW9kZT09Myl7XHQvLyBjaGVjayBpZiBjYW4gYmUgYmxlbmRlZFxuXHRcdFx0XHR2YXIgZmEgPSBzYltzaSszXSwgZnI9c2Jbc2ldLCBmZz1zYltzaSsxXSwgZmI9c2Jbc2krMl07IFxuXHRcdFx0XHR2YXIgYmEgPSB0Ylt0aSszXSwgYnI9dGJbdGldLCBiZz10Ylt0aSsxXSwgYmI9dGJbdGkrMl07IFxuXHRcdFx0XHRpZihmYT09YmEgJiYgZnI9PWJyICYmIGZnPT1iZyAmJiBmYj09YmIpIGNvbnRpbnVlO1xuXHRcdFx0XHQvL2lmKGZhIT0yNTUgJiYgYmEhPTApIHJldHVybiBmYWxzZTtcblx0XHRcdFx0aWYoZmE8MjIwICYmIGJhPjIwKSByZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuXG5cblxuVVBORy5lbmNvZGUgPSBmdW5jdGlvbihidWZzLCB3LCBoLCBwcywgZGVscywgdGFicywgZm9yYmlkUGx0ZSlcbntcblx0aWYocHM9PW51bGwpIHBzPTA7XG5cdGlmKGZvcmJpZFBsdGU9PW51bGwpIGZvcmJpZFBsdGUgPSBmYWxzZTtcblxuXHR2YXIgbmltZyA9IFVQTkcuZW5jb2RlLmNvbXByZXNzKGJ1ZnMsIHcsIGgsIHBzLCBbZmFsc2UsIGZhbHNlLCBmYWxzZSwgMCwgZm9yYmlkUGx0ZV0pO1xuXHRVUE5HLmVuY29kZS5jb21wcmVzc1BORyhuaW1nLCAtMSk7XG5cdFxuXHRyZXR1cm4gVVBORy5lbmNvZGUuX21haW4obmltZywgdywgaCwgZGVscywgdGFicyk7XG59XG5cblVQTkcuZW5jb2RlTEwgPSBmdW5jdGlvbihidWZzLCB3LCBoLCBjYywgYWMsIGRlcHRoLCBkZWxzLCB0YWJzKSB7XG5cdHZhciBuaW1nID0geyAgY3R5cGU6IDAgKyAoY2M9PTEgPyAwIDogMikgKyAoYWM9PTAgPyAwIDogNCksICAgICAgZGVwdGg6IGRlcHRoLCAgZnJhbWVzOiBbXSAgfTtcblx0XG5cdHZhciB0aW1lID0gRGF0ZS5ub3coKTtcblx0dmFyIGJpcHAgPSAoY2MrYWMpKmRlcHRoLCBiaXBsID0gYmlwcCAqIHc7XG5cdGZvcih2YXIgaT0wOyBpPGJ1ZnMubGVuZ3RoOyBpKyspXG5cdFx0bmltZy5mcmFtZXMucHVzaCh7ICByZWN0Ont4OjAseTowLHdpZHRoOncsaGVpZ2h0Omh9LCAgaW1nOm5ldyBVaW50OEFycmF5KGJ1ZnNbaV0pLCBibGVuZDowLCBkaXNwb3NlOjEsIGJwcDpNYXRoLmNlaWwoYmlwcC84KSwgYnBsOk1hdGguY2VpbChiaXBsLzgpICB9KTtcblx0XG5cdFVQTkcuZW5jb2RlLmNvbXByZXNzUE5HKG5pbWcsIDAsIHRydWUpO1xuXHRcblx0dmFyIG91dCA9IFVQTkcuZW5jb2RlLl9tYWluKG5pbWcsIHcsIGgsIGRlbHMsIHRhYnMpO1xuXHRyZXR1cm4gb3V0O1xufVxuXG5VUE5HLmVuY29kZS5fbWFpbiA9IGZ1bmN0aW9uKG5pbWcsIHcsIGgsIGRlbHMsIHRhYnMpIHtcblx0aWYodGFicz09bnVsbCkgdGFicz17fTtcblx0dmFyIGNyYyA9IFVQTkcuY3JjLmNyYywgd1VpID0gVVBORy5fYmluLndyaXRlVWludCwgd1VzID0gVVBORy5fYmluLndyaXRlVXNob3J0LCB3QXMgPSBVUE5HLl9iaW4ud3JpdGVBU0NJSTtcblx0dmFyIG9mZnNldCA9IDgsIGFuaW0gPSBuaW1nLmZyYW1lcy5sZW5ndGg+MSwgcGx0QWxwaGEgPSBmYWxzZTtcblx0XG5cdHZhciBsZW5nID0gOCArICgxNis1KzQpIC8qKyAoOSs0KSovICsgKGFuaW0gPyAyMCA6IDApO1xuXHRpZih0YWJzW1wic1JHQlwiXSE9bnVsbCkgbGVuZyArPSA4KzErNDtcblx0aWYodGFic1tcInBIWXNcIl0hPW51bGwpIGxlbmcgKz0gOCs5KzQ7XG5cdGlmKG5pbWcuY3R5cGU9PTMpIHtcblx0XHR2YXIgZGwgPSBuaW1nLnBsdGUubGVuZ3RoO1xuXHRcdGZvcih2YXIgaT0wOyBpPGRsOyBpKyspIGlmKChuaW1nLnBsdGVbaV0+Pj4yNCkhPTI1NSkgcGx0QWxwaGEgPSB0cnVlO1xuXHRcdGxlbmcgKz0gKDggKyBkbCozICsgNCkgKyAocGx0QWxwaGEgPyAoOCArIGRsKjEgKyA0KSA6IDApO1xuXHR9XG5cdGZvcih2YXIgaj0wOyBqPG5pbWcuZnJhbWVzLmxlbmd0aDsgaisrKVxuXHR7XG5cdFx0dmFyIGZyID0gbmltZy5mcmFtZXNbal07XG5cdFx0aWYoYW5pbSkgbGVuZyArPSAzODtcblx0XHRsZW5nICs9IGZyLmNpbWcubGVuZ3RoICsgMTI7XG5cdFx0aWYoaiE9MCkgbGVuZys9NDtcblx0fVxuXHRsZW5nICs9IDEyOyBcblx0XG5cdHZhciBkYXRhID0gbmV3IFVpbnQ4QXJyYXkobGVuZyk7XG5cdHZhciB3cj1bMHg4OSwgMHg1MCwgMHg0ZSwgMHg0NywgMHgwZCwgMHgwYSwgMHgxYSwgMHgwYV07XG5cdGZvcih2YXIgaT0wOyBpPDg7IGkrKykgZGF0YVtpXT13cltpXTtcblx0XG5cdHdVaShkYXRhLG9mZnNldCwgMTMpOyAgICAgb2Zmc2V0Kz00O1xuXHR3QXMoZGF0YSxvZmZzZXQsXCJJSERSXCIpOyAgb2Zmc2V0Kz00O1xuXHR3VWkoZGF0YSxvZmZzZXQsdyk7ICBvZmZzZXQrPTQ7XG5cdHdVaShkYXRhLG9mZnNldCxoKTsgIG9mZnNldCs9NDtcblx0ZGF0YVtvZmZzZXRdID0gbmltZy5kZXB0aDsgIG9mZnNldCsrOyAgLy8gZGVwdGhcblx0ZGF0YVtvZmZzZXRdID0gbmltZy5jdHlwZTsgIG9mZnNldCsrOyAgLy8gY3R5cGVcblx0ZGF0YVtvZmZzZXRdID0gMDsgIG9mZnNldCsrOyAgLy8gY29tcHJlc3Ncblx0ZGF0YVtvZmZzZXRdID0gMDsgIG9mZnNldCsrOyAgLy8gZmlsdGVyXG5cdGRhdGFbb2Zmc2V0XSA9IDA7ICBvZmZzZXQrKzsgIC8vIGludGVybGFjZVxuXHR3VWkoZGF0YSxvZmZzZXQsY3JjKGRhdGEsb2Zmc2V0LTE3LDE3KSk7ICBvZmZzZXQrPTQ7IC8vIGNyY1xuXG5cdC8vIDEzIGJ5dGVzIHRvIHNheSwgdGhhdCBpdCBpcyBzUkdCXG5cdGlmKHRhYnNbXCJzUkdCXCJdIT1udWxsKSB7XG5cdFx0d1VpKGRhdGEsb2Zmc2V0LCAxKTsgICAgICBvZmZzZXQrPTQ7XG5cdFx0d0FzKGRhdGEsb2Zmc2V0LFwic1JHQlwiKTsgIG9mZnNldCs9NDtcblx0XHRkYXRhW29mZnNldF0gPSB0YWJzW1wic1JHQlwiXTsgIG9mZnNldCsrO1xuXHRcdHdVaShkYXRhLG9mZnNldCxjcmMoZGF0YSxvZmZzZXQtNSw1KSk7ICBvZmZzZXQrPTQ7IC8vIGNyY1xuXHR9XG5cdGlmKHRhYnNbXCJwSFlzXCJdIT1udWxsKSB7XG5cdFx0d1VpKGRhdGEsb2Zmc2V0LCA5KTsgICAgICBvZmZzZXQrPTQ7XG5cdFx0d0FzKGRhdGEsb2Zmc2V0LFwicEhZc1wiKTsgIG9mZnNldCs9NDtcblx0XHR3VWkoZGF0YSxvZmZzZXQsIHRhYnNbXCJwSFlzXCJdWzBdKTsgICAgICBvZmZzZXQrPTQ7XG5cdFx0d1VpKGRhdGEsb2Zmc2V0LCB0YWJzW1wicEhZc1wiXVsxXSk7ICAgICAgb2Zmc2V0Kz00O1xuXHRcdGRhdGFbb2Zmc2V0XT10YWJzW1wicEhZc1wiXVsyXTtcdFx0XHRvZmZzZXQrKztcblx0XHR3VWkoZGF0YSxvZmZzZXQsY3JjKGRhdGEsb2Zmc2V0LTEzLDEzKSk7ICBvZmZzZXQrPTQ7IC8vIGNyY1xuXHR9XG5cblx0aWYoYW5pbSkge1xuXHRcdHdVaShkYXRhLG9mZnNldCwgOCk7ICAgICAgb2Zmc2V0Kz00O1xuXHRcdHdBcyhkYXRhLG9mZnNldCxcImFjVExcIik7ICBvZmZzZXQrPTQ7XG5cdFx0d1VpKGRhdGEsb2Zmc2V0LCBuaW1nLmZyYW1lcy5sZW5ndGgpOyAgICAgb2Zmc2V0Kz00O1xuXHRcdHdVaShkYXRhLG9mZnNldCwgdGFic1tcImxvb3BcIl0hPW51bGw/dGFic1tcImxvb3BcIl06MCk7ICAgICAgb2Zmc2V0Kz00O1xuXHRcdHdVaShkYXRhLG9mZnNldCxjcmMoZGF0YSxvZmZzZXQtMTIsMTIpKTsgIG9mZnNldCs9NDsgLy8gY3JjXG5cdH1cblxuXHRpZihuaW1nLmN0eXBlPT0zKSB7XG5cdFx0dmFyIGRsID0gbmltZy5wbHRlLmxlbmd0aDtcblx0XHR3VWkoZGF0YSxvZmZzZXQsIGRsKjMpOyAgb2Zmc2V0Kz00O1xuXHRcdHdBcyhkYXRhLG9mZnNldCxcIlBMVEVcIik7ICBvZmZzZXQrPTQ7XG5cdFx0Zm9yKHZhciBpPTA7IGk8ZGw7IGkrKyl7XG5cdFx0XHR2YXIgdGk9aSozLCBjPW5pbWcucGx0ZVtpXSwgcj0oYykmMjU1LCBnPShjPj4+OCkmMjU1LCBiPShjPj4+MTYpJjI1NTtcblx0XHRcdGRhdGFbb2Zmc2V0K3RpKzBdPXI7ICBkYXRhW29mZnNldCt0aSsxXT1nOyAgZGF0YVtvZmZzZXQrdGkrMl09Yjtcblx0XHR9XG5cdFx0b2Zmc2V0Kz1kbCozO1xuXHRcdHdVaShkYXRhLG9mZnNldCxjcmMoZGF0YSxvZmZzZXQtZGwqMy00LGRsKjMrNCkpOyAgb2Zmc2V0Kz00OyAvLyBjcmNcblxuXHRcdGlmKHBsdEFscGhhKSB7XG5cdFx0XHR3VWkoZGF0YSxvZmZzZXQsIGRsKTsgIG9mZnNldCs9NDtcblx0XHRcdHdBcyhkYXRhLG9mZnNldCxcInRSTlNcIik7ICBvZmZzZXQrPTQ7XG5cdFx0XHRmb3IodmFyIGk9MDsgaTxkbDsgaSsrKSAgZGF0YVtvZmZzZXQraV09KG5pbWcucGx0ZVtpXT4+PjI0KSYyNTU7XG5cdFx0XHRvZmZzZXQrPWRsO1xuXHRcdFx0d1VpKGRhdGEsb2Zmc2V0LGNyYyhkYXRhLG9mZnNldC1kbC00LGRsKzQpKTsgIG9mZnNldCs9NDsgLy8gY3JjXG5cdFx0fVxuXHR9XG5cdFxuXHR2YXIgZmkgPSAwO1xuXHRmb3IodmFyIGo9MDsgajxuaW1nLmZyYW1lcy5sZW5ndGg7IGorKylcblx0e1xuXHRcdHZhciBmciA9IG5pbWcuZnJhbWVzW2pdO1xuXHRcdGlmKGFuaW0pIHtcblx0XHRcdHdVaShkYXRhLCBvZmZzZXQsIDI2KTsgICAgIG9mZnNldCs9NDtcblx0XHRcdHdBcyhkYXRhLCBvZmZzZXQsXCJmY1RMXCIpOyAgb2Zmc2V0Kz00O1xuXHRcdFx0d1VpKGRhdGEsIG9mZnNldCwgZmkrKyk7ICAgb2Zmc2V0Kz00O1xuXHRcdFx0d1VpKGRhdGEsIG9mZnNldCwgZnIucmVjdC53aWR0aCApOyAgIG9mZnNldCs9NDtcblx0XHRcdHdVaShkYXRhLCBvZmZzZXQsIGZyLnJlY3QuaGVpZ2h0KTsgICBvZmZzZXQrPTQ7XG5cdFx0XHR3VWkoZGF0YSwgb2Zmc2V0LCBmci5yZWN0LngpOyAgIG9mZnNldCs9NDtcblx0XHRcdHdVaShkYXRhLCBvZmZzZXQsIGZyLnJlY3QueSk7ICAgb2Zmc2V0Kz00O1xuXHRcdFx0d1VzKGRhdGEsIG9mZnNldCwgZGVsc1tqXSk7ICAgb2Zmc2V0Kz0yO1xuXHRcdFx0d1VzKGRhdGEsIG9mZnNldCwgIDEwMDApOyAgIG9mZnNldCs9Mjtcblx0XHRcdGRhdGFbb2Zmc2V0XSA9IGZyLmRpc3Bvc2U7ICBvZmZzZXQrKztcdC8vIGRpc3Bvc2Vcblx0XHRcdGRhdGFbb2Zmc2V0XSA9IGZyLmJsZW5kICA7ICBvZmZzZXQrKztcdC8vIGJsZW5kXG5cdFx0XHR3VWkoZGF0YSxvZmZzZXQsY3JjKGRhdGEsb2Zmc2V0LTMwLDMwKSk7ICBvZmZzZXQrPTQ7IC8vIGNyY1xuXHRcdH1cblx0XHRcdFx0XG5cdFx0dmFyIGltZ2QgPSBmci5jaW1nLCBkbCA9IGltZ2QubGVuZ3RoO1xuXHRcdHdVaShkYXRhLG9mZnNldCwgZGwrKGo9PTA/MDo0KSk7ICAgICBvZmZzZXQrPTQ7XG5cdFx0dmFyIGlvZmYgPSBvZmZzZXQ7XG5cdFx0d0FzKGRhdGEsb2Zmc2V0LChqPT0wKT9cIklEQVRcIjpcImZkQVRcIik7ICBvZmZzZXQrPTQ7XG5cdFx0aWYoaiE9MCkgeyAgd1VpKGRhdGEsIG9mZnNldCwgZmkrKyk7ICBvZmZzZXQrPTQ7ICB9XG5cdFx0ZGF0YS5zZXQoaW1nZCxvZmZzZXQpO1xuXHRcdG9mZnNldCArPSBkbDtcblx0XHR3VWkoZGF0YSxvZmZzZXQsY3JjKGRhdGEsaW9mZixvZmZzZXQtaW9mZikpOyAgb2Zmc2V0Kz00OyAvLyBjcmNcblx0fVxuXG5cdHdVaShkYXRhLG9mZnNldCwgMCk7ICAgICBvZmZzZXQrPTQ7XG5cdHdBcyhkYXRhLG9mZnNldCxcIklFTkRcIik7ICBvZmZzZXQrPTQ7XG5cdHdVaShkYXRhLG9mZnNldCxjcmMoZGF0YSxvZmZzZXQtNCw0KSk7ICBvZmZzZXQrPTQ7IC8vIGNyY1xuXG5cdHJldHVybiBkYXRhLmJ1ZmZlcjtcbn1cblxuVVBORy5lbmNvZGUuY29tcHJlc3NQTkcgPSBmdW5jdGlvbihvdXQsIGZpbHRlciwgbGV2ZWxaZXJvKSB7XG5cdGZvcih2YXIgaT0wOyBpPG91dC5mcmFtZXMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgZnJtID0gb3V0LmZyYW1lc1tpXSwgbnc9ZnJtLnJlY3Qud2lkdGgsIG5oPWZybS5yZWN0LmhlaWdodDtcblx0XHR2YXIgZmRhdGEgPSBuZXcgVWludDhBcnJheShuaCpmcm0uYnBsK25oKTtcblx0XHRmcm0uY2ltZyA9IFVQTkcuZW5jb2RlLl9maWx0ZXJaZXJvKGZybS5pbWcsbmgsZnJtLmJwcCxmcm0uYnBsLGZkYXRhLCBmaWx0ZXIsIGxldmVsWmVybyk7XG5cdH1cbn1cblxuXG5cblVQTkcuZW5jb2RlLmNvbXByZXNzID0gZnVuY3Rpb24oYnVmcywgdywgaCwgcHMsIHBybXMpIC8vIHBybXM6ICBvbmx5QmxlbmQsIG1pbkJpdHMsIGZvcmJpZFBsdGVcbntcblx0Ly92YXIgdGltZSA9IERhdGUubm93KCk7XG5cdHZhciBvbmx5QmxlbmQgPSBwcm1zWzBdLCBldmVuQ3JkID0gcHJtc1sxXSwgZm9yYmlkUHJldiA9IHBybXNbMl0sIG1pbkJpdHMgPSBwcm1zWzNdLCBmb3JiaWRQbHRlID0gcHJtc1s0XTtcblx0XG5cdHZhciBjdHlwZSA9IDYsIGRlcHRoID0gOCwgYWxwaGFBbmQ9MjU1XG5cdFxuXHRmb3IodmFyIGo9MDsgajxidWZzLmxlbmd0aDsgaisrKSAgeyAgLy8gd2hlbiBub3QgcXVhbnRpemVkLCBvdGhlciBmcmFtZXMgY2FuIGNvbnRhaW4gY29sb3JzLCB0aGF0IGFyZSBub3QgaW4gYW4gaW5pdGlhbCBmcmFtZVxuXHRcdHZhciBpbWcgPSBuZXcgVWludDhBcnJheShidWZzW2pdKSwgaWxlbiA9IGltZy5sZW5ndGg7XG5cdFx0Zm9yKHZhciBpPTA7IGk8aWxlbjsgaSs9NCkgYWxwaGFBbmQgJj0gaW1nW2krM107XG5cdH1cblx0dmFyIGdvdEFscGhhID0gKGFscGhhQW5kIT0yNTUpO1xuXHRcblx0Ly9jb25zb2xlLmxvZyhcImFscGhhIGNoZWNrXCIsIERhdGUubm93KCktdGltZSk7ICB0aW1lID0gRGF0ZS5ub3coKTtcblx0XG5cdC8vdmFyIGJydXRlID0gZ290QWxwaGEgJiYgZm9yR0lGO1x0XHQvLyBicnV0ZSA6IGZyYW1lcyBjYW4gb25seSBiZSBjb3BpZWQsIG5vdCBcImJsZW5kZWRcIlxuXHR2YXIgZnJtcyA9IFVQTkcuZW5jb2RlLmZyYW1pemUoYnVmcywgdywgaCwgb25seUJsZW5kLCBldmVuQ3JkLCBmb3JiaWRQcmV2KTtcblx0Ly9jb25zb2xlLmxvZyhcImZyYW1pemVcIiwgRGF0ZS5ub3coKS10aW1lKTsgIHRpbWUgPSBEYXRlLm5vdygpO1xuXHRcblx0dmFyIGNtYXA9e30sIHBsdGU9W10sIGluZHM9W107ICBcblx0XG5cdGlmKHBzIT0wKSB7XG5cdFx0dmFyIG5idWZzID0gW107ICBmb3IodmFyIGk9MDsgaTxmcm1zLmxlbmd0aDsgaSsrKSBuYnVmcy5wdXNoKGZybXNbaV0uaW1nLmJ1ZmZlcik7XG5cdFx0XG5cdFx0dmFyIGFidWYgPSBVUE5HLmVuY29kZS5jb25jYXRSR0JBKG5idWZzKSwgcXJlcyA9IFVQTkcucXVhbnRpemUoYWJ1ZiwgcHMpOyAgXG5cdFx0dmFyIGNvZiA9IDAsIGJiID0gbmV3IFVpbnQ4QXJyYXkocXJlcy5hYnVmKTtcblx0XHRmb3IodmFyIGk9MDsgaTxmcm1zLmxlbmd0aDsgaSsrKSB7ICB2YXIgdGk9ZnJtc1tpXS5pbWcsIGJsbj10aS5sZW5ndGg7ICBpbmRzLnB1c2gobmV3IFVpbnQ4QXJyYXkocXJlcy5pbmRzLmJ1ZmZlciwgY29mPj4yLCBibG4+PjIpKTtcblx0XHRcdGZvcih2YXIgaj0wOyBqPGJsbjsgais9NCkgeyAgdGlbal09YmJbY29mK2pdOyAgdGlbaisxXT1iYltjb2YraisxXTsgIHRpW2orMl09YmJbY29mK2orMl07ICB0aVtqKzNdPWJiW2NvZitqKzNdOyAgfSAgICBjb2YrPWJsbjsgIH1cblx0XHRcblx0XHRmb3IodmFyIGk9MDsgaTxxcmVzLnBsdGUubGVuZ3RoOyBpKyspIHBsdGUucHVzaChxcmVzLnBsdGVbaV0uZXN0LnJnYmEpO1xuXHRcdC8vY29uc29sZS5sb2coXCJxdWFudGl6ZVwiLCBEYXRlLm5vdygpLXRpbWUpOyAgdGltZSA9IERhdGUubm93KCk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gd2hhdCBpZiBwcz09MCwgYnV0IHRoZXJlIGFyZSA8PTI1NiBjb2xvcnM/ICB3ZSBzdGlsbCBuZWVkIHRvIGRldGVjdCwgaWYgdGhlIHBhbGV0dGUgY291bGQgYmUgdXNlZFxuXHRcdGZvcih2YXIgaj0wOyBqPGZybXMubGVuZ3RoOyBqKyspICB7ICAvLyB3aGVuIG5vdCBxdWFudGl6ZWQsIG90aGVyIGZyYW1lcyBjYW4gY29udGFpbiBjb2xvcnMsIHRoYXQgYXJlIG5vdCBpbiBhbiBpbml0aWFsIGZyYW1lXG5cdFx0XHR2YXIgZnJtID0gZnJtc1tqXSwgaW1nMzIgPSBuZXcgVWludDMyQXJyYXkoZnJtLmltZy5idWZmZXIpLCBudz1mcm0ucmVjdC53aWR0aCwgaWxlbiA9IGltZzMyLmxlbmd0aDtcblx0XHRcdHZhciBpbmQgPSBuZXcgVWludDhBcnJheShpbGVuKTsgIGluZHMucHVzaChpbmQpO1xuXHRcdFx0Zm9yKHZhciBpPTA7IGk8aWxlbjsgaSsrKSB7XG5cdFx0XHRcdHZhciBjID0gaW1nMzJbaV07XG5cdFx0XHRcdGlmICAgICAoaSE9MCAmJiBjPT1pbWczMltpLSAxXSkgaW5kW2ldPWluZFtpLTFdO1xuXHRcdFx0XHRlbHNlIGlmKGk+bncgJiYgYz09aW1nMzJbaS1ud10pIGluZFtpXT1pbmRbaS1ud107XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHZhciBjbWMgPSBjbWFwW2NdO1xuXHRcdFx0XHRcdGlmKGNtYz09bnVsbCkgeyAgY21hcFtjXT1jbWM9cGx0ZS5sZW5ndGg7ICBwbHRlLnB1c2goYyk7ICBpZihwbHRlLmxlbmd0aD49MzAwKSBicmVhazsgIH1cblx0XHRcdFx0XHRpbmRbaV09Y21jO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8vY29uc29sZS5sb2coXCJtYWtlIHBhbGV0dGVcIiwgRGF0ZS5ub3coKS10aW1lKTsgIHRpbWUgPSBEYXRlLm5vdygpO1xuXHR9XG5cdFxuXHR2YXIgY2M9cGx0ZS5sZW5ndGg7IC8vY29uc29sZS5sb2coXCJjb2xvcnM6XCIsY2MpO1xuXHRpZihjYzw9MjU2ICYmIGZvcmJpZFBsdGU9PWZhbHNlKSB7XG5cdFx0aWYoY2M8PSAyKSBkZXB0aD0xOyAgZWxzZSBpZihjYzw9IDQpIGRlcHRoPTI7ICBlbHNlIGlmKGNjPD0xNikgZGVwdGg9NDsgIGVsc2UgZGVwdGg9ODtcblx0XHRkZXB0aCA9ICBNYXRoLm1heChkZXB0aCwgbWluQml0cyk7XG5cdH1cblx0XG5cdGZvcih2YXIgaj0wOyBqPGZybXMubGVuZ3RoOyBqKyspXG5cdHtcblx0XHR2YXIgZnJtID0gZnJtc1tqXSwgbng9ZnJtLnJlY3QueCwgbnk9ZnJtLnJlY3QueSwgbnc9ZnJtLnJlY3Qud2lkdGgsIG5oPWZybS5yZWN0LmhlaWdodDtcblx0XHR2YXIgY2ltZyA9IGZybS5pbWcsIGNpbWczMiA9IG5ldyBVaW50MzJBcnJheShjaW1nLmJ1ZmZlcik7XG5cdFx0dmFyIGJwbCA9IDQqbncsIGJwcD00O1xuXHRcdGlmKGNjPD0yNTYgJiYgZm9yYmlkUGx0ZT09ZmFsc2UpIHtcblx0XHRcdGJwbCA9IE1hdGguY2VpbChkZXB0aCpudy84KTtcblx0XHRcdHZhciBuaW1nID0gbmV3IFVpbnQ4QXJyYXkoYnBsKm5oKTtcblx0XHRcdHZhciBpbmogPSBpbmRzW2pdO1xuXHRcdFx0Zm9yKHZhciB5PTA7IHk8bmg7IHkrKykgeyAgdmFyIGk9eSpicGwsIGlpPXkqbnc7XG5cdFx0XHRcdGlmICAgICAoZGVwdGg9PTgpIGZvcih2YXIgeD0wOyB4PG53OyB4KyspIG5pbWdbaSsoeCkgICBdICAgPSAgKGlualtpaSt4XSAgICAgICAgICAgICApO1xuXHRcdFx0XHRlbHNlIGlmKGRlcHRoPT00KSBmb3IodmFyIHg9MDsgeDxudzsgeCsrKSBuaW1nW2krKHg+PjEpXSAgfD0gIChpbmpbaWkreF08PCg0LSh4JjEpKjQpKTtcblx0XHRcdFx0ZWxzZSBpZihkZXB0aD09MikgZm9yKHZhciB4PTA7IHg8bnc7IHgrKykgbmltZ1tpKyh4Pj4yKV0gIHw9ICAoaW5qW2lpK3hdPDwoNi0oeCYzKSoyKSk7XG5cdFx0XHRcdGVsc2UgaWYoZGVwdGg9PTEpIGZvcih2YXIgeD0wOyB4PG53OyB4KyspIG5pbWdbaSsoeD4+MyldICB8PSAgKGlualtpaSt4XTw8KDctKHgmNykqMSkpO1xuXHRcdFx0fVxuXHRcdFx0Y2ltZz1uaW1nOyAgY3R5cGU9MzsgIGJwcD0xO1xuXHRcdH1cblx0XHRlbHNlIGlmKGdvdEFscGhhPT1mYWxzZSAmJiBmcm1zLmxlbmd0aD09MSkge1x0Ly8gc29tZSBuZXh0IFwicmVkdWNlZFwiIGZyYW1lcyBtYXkgY29udGFpbiBhbHBoYSBmb3IgYmxlbmRpbmdcblx0XHRcdHZhciBuaW1nID0gbmV3IFVpbnQ4QXJyYXkobncqbmgqMyksIGFyZWE9bncqbmg7XG5cdFx0XHRmb3IodmFyIGk9MDsgaTxhcmVhOyBpKyspIHsgdmFyIHRpPWkqMywgcWk9aSo0OyAgbmltZ1t0aV09Y2ltZ1txaV07ICBuaW1nW3RpKzFdPWNpbWdbcWkrMV07ICBuaW1nW3RpKzJdPWNpbWdbcWkrMl07ICB9XG5cdFx0XHRjaW1nPW5pbWc7ICBjdHlwZT0yOyAgYnBwPTM7ICBicGw9Mypudztcblx0XHR9XG5cdFx0ZnJtLmltZz1jaW1nOyAgZnJtLmJwbD1icGw7ICBmcm0uYnBwPWJwcDtcblx0fVxuXHQvL2NvbnNvbGUubG9nKFwiY29sb3JzID0+IHBhbGV0dGUgaW5kaWNlc1wiLCBEYXRlLm5vdygpLXRpbWUpOyAgdGltZSA9IERhdGUubm93KCk7XG5cdFxuXHRyZXR1cm4ge2N0eXBlOmN0eXBlLCBkZXB0aDpkZXB0aCwgcGx0ZTpwbHRlLCBmcmFtZXM6ZnJtcyAgfTtcbn1cblVQTkcuZW5jb2RlLmZyYW1pemUgPSBmdW5jdGlvbihidWZzLHcsaCxhbHdheXNCbGVuZCxldmVuQ3JkLGZvcmJpZFByZXYpIHtcblx0LyogIERJU1BPU0Vcblx0ICAgIC0gMCA6IG5vIGNoYW5nZVxuXHRcdC0gMSA6IGNsZWFyIHRvIHRyYW5zcGFyZW50XG5cdFx0LSAyIDogcmV0c3RvcmUgdG8gY29udGVudCBiZWZvcmUgcmVuZGVyaW5nIChwcmV2aW91cyBmcmFtZSBkaXNwb3NlZClcblx0XHRCTEVORFxuXHRcdC0gMCA6IHJlcGxhY2Vcblx0XHQtIDEgOiBibGVuZFxuXHQqL1xuXHR2YXIgZnJtcyA9IFtdO1xuXHRmb3IodmFyIGo9MDsgajxidWZzLmxlbmd0aDsgaisrKSB7XG5cdFx0dmFyIGNpbWcgPSBuZXcgVWludDhBcnJheShidWZzW2pdKSwgY2ltZzMyID0gbmV3IFVpbnQzMkFycmF5KGNpbWcuYnVmZmVyKTtcblx0XHR2YXIgbmltZztcblx0XHRcblx0XHR2YXIgbng9MCwgbnk9MCwgbnc9dywgbmg9aCwgYmxlbmQ9YWx3YXlzQmxlbmQ/MTowO1xuXHRcdGlmKGohPTApIHtcblx0XHRcdHZhciB0bGltID0gKGZvcmJpZFByZXYgfHwgYWx3YXlzQmxlbmQgfHwgaj09MSB8fCBmcm1zW2otMl0uZGlzcG9zZSE9MCk/MToyLCB0c3RwID0gMCwgdGFyZWEgPSAxZTk7XG5cdFx0XHRmb3IodmFyIGl0PTA7IGl0PHRsaW07IGl0KyspXG5cdFx0XHR7XG5cdFx0XHRcdHZhciBwaW1nID0gbmV3IFVpbnQ4QXJyYXkoYnVmc1tqLTEtaXRdKSwgcDMyID0gbmV3IFVpbnQzMkFycmF5KGJ1ZnNbai0xLWl0XSk7XG5cdFx0XHRcdHZhciBtaXg9dyxtaXk9aCxtYXg9LTEsbWF5PS0xO1xuXHRcdFx0XHRmb3IodmFyIHk9MDsgeTxoOyB5KyspIGZvcih2YXIgeD0wOyB4PHc7IHgrKykge1xuXHRcdFx0XHRcdHZhciBpID0geSp3K3g7XG5cdFx0XHRcdFx0aWYoY2ltZzMyW2ldIT1wMzJbaV0pIHtcblx0XHRcdFx0XHRcdGlmKHg8bWl4KSBtaXg9eDsgIGlmKHg+bWF4KSBtYXg9eDtcblx0XHRcdFx0XHRcdGlmKHk8bWl5KSBtaXk9eTsgIGlmKHk+bWF5KSBtYXk9eTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYobWF4PT0tMSkgbWl4PW1peT1tYXg9bWF5PTA7XG5cdFx0XHRcdGlmKGV2ZW5DcmQpIHsgIGlmKChtaXgmMSk9PTEpbWl4LS07ICBpZigobWl5JjEpPT0xKW1peS0tOyAgfVxuXHRcdFx0XHR2YXIgc2FyZWEgPSAobWF4LW1peCsxKSoobWF5LW1peSsxKTtcblx0XHRcdFx0aWYoc2FyZWE8dGFyZWEpIHtcblx0XHRcdFx0XHR0YXJlYSA9IHNhcmVhOyAgdHN0cCA9IGl0O1xuXHRcdFx0XHRcdG54ID0gbWl4OyBueSA9IG1peTsgbncgPSBtYXgtbWl4KzE7IG5oID0gbWF5LW1peSsxO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIGFsd2F5c0JsZW5kOiBwb2t1ZCB6amlzdMOtbSwgxb5lIGJsZW5kaXQgbmVsemUsIG5hc3RhdsOtbSBwxZllZGNob3rDrW11IHNuw61ta3UgZGlzcG9zZT0xLiBaYWppc3TDrW0sIGFieSBvYnNhaG92YWwgbcWvaiBvYmTDqWxuw61rLlxuXHRcdFx0dmFyIHBpbWcgPSBuZXcgVWludDhBcnJheShidWZzW2otMS10c3RwXSk7XG5cdFx0XHRpZih0c3RwPT0xKSBmcm1zW2otMV0uZGlzcG9zZSA9IDI7XG5cdFx0XHRcblx0XHRcdG5pbWcgPSBuZXcgVWludDhBcnJheShudypuaCo0KTtcblx0XHRcdFVQTkcuX2NvcHlUaWxlKHBpbWcsdyxoLCBuaW1nLG53LG5oLCAtbngsLW55LCAwKTtcblx0XHRcdFxuXHRcdFx0YmxlbmQgPSAgVVBORy5fY29weVRpbGUoY2ltZyx3LGgsIG5pbWcsbncsbmgsIC1ueCwtbnksIDMpID8gMSA6IDA7XG5cdFx0XHRpZihibGVuZD09MSkgVVBORy5lbmNvZGUuX3ByZXBhcmVEaWZmKGNpbWcsdyxoLG5pbWcse3g6bngseTpueSx3aWR0aDpudyxoZWlnaHQ6bmh9KTtcblx0XHRcdGVsc2UgICAgICAgICBVUE5HLl9jb3B5VGlsZShjaW1nLHcsaCwgbmltZyxudyxuaCwgLW54LC1ueSwgMCk7XG5cdFx0XHQvL1VQTkcuX2NvcHlUaWxlKGNpbWcsdyxoLCBuaW1nLG53LG5oLCAtbngsLW55LCBibGVuZD09MT8yOjApO1xuXHRcdH1cblx0XHRlbHNlIG5pbWcgPSBjaW1nLnNsaWNlKDApO1x0Ly8gaW1nIG1heSBiZSByZXdyaXR0ZW4gZnVydGhlciAuLi4gZG9uJ3QgcmV3cml0ZSBpbnB1dFxuXHRcdFxuXHRcdGZybXMucHVzaCh7cmVjdDp7eDpueCx5Om55LHdpZHRoOm53LGhlaWdodDpuaH0sIGltZzpuaW1nLCBibGVuZDpibGVuZCwgZGlzcG9zZTowfSk7XG5cdH1cblx0XG5cdFxuXHRpZihhbHdheXNCbGVuZCkgZm9yKHZhciBqPTA7IGo8ZnJtcy5sZW5ndGg7IGorKykge1xuXHRcdHZhciBmcm0gPSBmcm1zW2pdOyAgaWYoZnJtLmJsZW5kPT0xKSBjb250aW51ZTtcblx0XHR2YXIgcjAgPSBmcm0ucmVjdCwgcjEgPSBmcm1zW2otMV0ucmVjdFxuXHRcdHZhciBtaVggPSBNYXRoLm1pbihyMC54LCByMS54KSwgbWlZID0gTWF0aC5taW4ocjAueSwgcjEueSk7XG5cdFx0dmFyIG1hWCA9IE1hdGgubWF4KHIwLngrcjAud2lkdGgsIHIxLngrcjEud2lkdGgpLCBtYVkgPSBNYXRoLm1heChyMC55K3IwLmhlaWdodCwgcjEueStyMS5oZWlnaHQpO1xuXHRcdHZhciByID0ge3g6bWlYLCB5Om1pWSwgd2lkdGg6bWFYLW1pWCwgaGVpZ2h0Om1hWS1taVl9O1xuXHRcdFxuXHRcdGZybXNbai0xXS5kaXNwb3NlID0gMTtcblx0XHRpZihqLTEhPTApIFxuXHRcdFVQTkcuZW5jb2RlLl91cGRhdGVGcmFtZShidWZzLCB3LGgsZnJtcywgai0xLHIsIGV2ZW5DcmQpO1xuXHRcdFVQTkcuZW5jb2RlLl91cGRhdGVGcmFtZShidWZzLCB3LGgsZnJtcywgaiAgLHIsIGV2ZW5DcmQpO1xuXHR9XG5cdHZhciBhcmVhID0gMDtcblx0aWYoYnVmcy5sZW5ndGghPTEpIGZvcih2YXIgaT0wOyBpPGZybXMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgZnJtID0gZnJtc1tpXTtcblx0XHRhcmVhICs9IGZybS5yZWN0LndpZHRoKmZybS5yZWN0LmhlaWdodDtcblx0XHQvL2lmKGk9PTAgfHwgZnJtLmJsZW5kIT0xKSBjb250aW51ZTtcblx0XHQvL3ZhciBvYiA9IG5ldyBVaW50OEFycmF5KFxuXHRcdC8vY29uc29sZS5sb2coZnJtLmJsZW5kLCBmcm0uZGlzcG9zZSwgZnJtLnJlY3QpO1xuXHR9XG5cdC8vaWYoYXJlYSE9MCkgY29uc29sZS5sb2coYXJlYSk7XG5cdHJldHVybiBmcm1zO1xufVxuVVBORy5lbmNvZGUuX3VwZGF0ZUZyYW1lID0gZnVuY3Rpb24oYnVmcywgdyxoLCBmcm1zLCBpLCByLCBldmVuQ3JkKSB7XG5cdHZhciBVOCA9IFVpbnQ4QXJyYXksIFUzMiA9IFVpbnQzMkFycmF5O1xuXHR2YXIgcGltZyA9IG5ldyBVOChidWZzW2ktMV0pLCBwaW1nMzIgPSBuZXcgVTMyKGJ1ZnNbaS0xXSksIG5pbWcgPSBpKzE8YnVmcy5sZW5ndGggPyBuZXcgVTgoYnVmc1tpKzFdKTpudWxsO1xuXHR2YXIgY2ltZyA9IG5ldyBVOChidWZzW2ldKSwgY2ltZzMyID0gbmV3IFUzMihjaW1nLmJ1ZmZlcik7XG5cdFxuXHR2YXIgbWl4PXcsbWl5PWgsbWF4PS0xLG1heT0tMTtcblx0Zm9yKHZhciB5PTA7IHk8ci5oZWlnaHQ7IHkrKykgZm9yKHZhciB4PTA7IHg8ci53aWR0aDsgeCsrKSB7XG5cdFx0dmFyIGN4ID0gci54K3gsIGN5ID0gci55K3k7XG5cdFx0dmFyIGogPSBjeSp3K2N4LCBjYyA9IGNpbWczMltqXTtcblx0XHQvLyBubyBuZWVkIHRvIGRyYXcgdHJhbnNwYXJlbmN5LCBvciB0byBkaXNwb3NlIGl0LiBPciwgaWYgd3JpdGluZyB0aGUgc2FtZSBjb2xvciBhbmQgdGhlIG5leHQgb25lIGRvZXMgbm90IG5lZWQgdHJhbnNwYXJlbmN5LlxuXHRcdGlmKGNjPT0wIHx8IChmcm1zW2ktMV0uZGlzcG9zZT09MCAmJiBwaW1nMzJbal09PWNjICYmIChuaW1nPT1udWxsIHx8IG5pbWdbaio0KzNdIT0wKSkvKiovKSB7fVxuXHRcdGVsc2Uge1xuXHRcdFx0aWYoY3g8bWl4KSBtaXg9Y3g7ICBpZihjeD5tYXgpIG1heD1jeDtcblx0XHRcdGlmKGN5PG1peSkgbWl5PWN5OyAgaWYoY3k+bWF5KSBtYXk9Y3k7XG5cdFx0fVxuXHR9XG5cdGlmKG1heD09LTEpIG1peD1taXk9bWF4PW1heT0wO1xuXHRpZihldmVuQ3JkKSB7ICBpZigobWl4JjEpPT0xKW1peC0tOyAgaWYoKG1peSYxKT09MSltaXktLTsgIH1cblx0ciA9IHt4Om1peCwgeTptaXksIHdpZHRoOm1heC1taXgrMSwgaGVpZ2h0Om1heS1taXkrMX07XG5cdFxuXHR2YXIgZnIgPSBmcm1zW2ldOyAgZnIucmVjdCA9IHI7ICBmci5ibGVuZCA9IDE7ICBmci5pbWcgPSBuZXcgVWludDhBcnJheShyLndpZHRoKnIuaGVpZ2h0KjQpO1xuXHRpZihmcm1zW2ktMV0uZGlzcG9zZT09MCkge1xuXHRcdFVQTkcuX2NvcHlUaWxlKHBpbWcsdyxoLCBmci5pbWcsci53aWR0aCxyLmhlaWdodCwgLXIueCwtci55LCAwKTtcblx0XHRVUE5HLmVuY29kZS5fcHJlcGFyZURpZmYoY2ltZyx3LGgsZnIuaW1nLHIpO1xuXHRcdC8vVVBORy5fY29weVRpbGUoY2ltZyx3LGgsIGZyLmltZyxyLndpZHRoLHIuaGVpZ2h0LCAtci54LC1yLnksIDIpO1xuXHR9XG5cdGVsc2Vcblx0XHRVUE5HLl9jb3B5VGlsZShjaW1nLHcsaCwgZnIuaW1nLHIud2lkdGgsci5oZWlnaHQsIC1yLngsLXIueSwgMCk7XG59XG5VUE5HLmVuY29kZS5fcHJlcGFyZURpZmYgPSBmdW5jdGlvbihjaW1nLCB3LGgsIG5pbWcsIHJlYykge1xuXHRVUE5HLl9jb3B5VGlsZShjaW1nLHcsaCwgbmltZyxyZWMud2lkdGgscmVjLmhlaWdodCwgLXJlYy54LC1yZWMueSwgMik7XG5cdC8qXG5cdHZhciBuMzIgPSBuZXcgVWludDMyQXJyYXkobmltZy5idWZmZXIpO1xuXHR2YXIgb2cgPSBuZXcgVWludDhBcnJheShyZWMud2lkdGgqcmVjLmhlaWdodCo0KSwgbzMyID0gbmV3IFVpbnQzMkFycmF5KG9nLmJ1ZmZlcik7XG5cdFVQTkcuX2NvcHlUaWxlKGNpbWcsdyxoLCBvZyxyZWMud2lkdGgscmVjLmhlaWdodCwgLXJlYy54LC1yZWMueSwgMCk7XG5cdGZvcih2YXIgaT00OyBpPG5pbWcubGVuZ3RoOyBpKz00KSB7XG5cdFx0aWYobmltZ1tpLTFdIT0wICYmIG5pbWdbaSszXT09MCAmJiBvMzJbaT4+PjJdPT1vMzJbKGk+Pj4yKS0xXSkge1xuXHRcdFx0bjMyW2k+Pj4yXT1vMzJbaT4+PjJdO1xuXHRcdFx0Ly92YXIgaiA9IGksIGM9cDMyWyhpPj4+MiktMV07XG5cdFx0XHQvL3doaWxlKHAzMltqPj4+Ml09PWMpIHsgIG4zMltqPj4+Ml09YzsgIGorPTQ7ICB9XG5cdFx0fVxuXHR9XG5cdGZvcih2YXIgaT1uaW1nLmxlbmd0aC04OyBpPjA7IGktPTQpIHtcblx0XHRpZihuaW1nW2krN10hPTAgJiYgbmltZ1tpKzNdPT0wICYmIG8zMltpPj4+Ml09PW8zMlsoaT4+PjIpKzFdKSB7XG5cdFx0XHRuMzJbaT4+PjJdPW8zMltpPj4+Ml07XG5cdFx0XHQvL3ZhciBqID0gaSwgYz1wMzJbKGk+Pj4yKS0xXTtcblx0XHRcdC8vd2hpbGUocDMyW2o+Pj4yXT09YykgeyAgbjMyW2o+Pj4yXT1jOyAgais9NDsgIH1cblx0XHR9XG5cdH0qL1xufVxuXG5VUE5HLmVuY29kZS5fZmlsdGVyWmVybyA9IGZ1bmN0aW9uKGltZyxoLGJwcCxicGwsZGF0YSwgZmlsdGVyLCBsZXZlbFplcm8pXG57XG5cdHZhciBmbHMgPSBbXSwgZnRyeT1bMCwxLDIsMyw0XTtcblx0aWYgICAgIChmaWx0ZXIhPS0xKSAgICAgICAgICAgICBmdHJ5PVtmaWx0ZXJdO1xuXHRlbHNlIGlmKGgqYnBsPjUwMDAwMCB8fCBicHA9PTEpIGZ0cnk9WzBdO1xuXHR2YXIgb3B0czsgIGlmKGxldmVsWmVybykgb3B0cz17bGV2ZWw6MH07XG5cdFxuXHR2YXIgQ01QUiA9IChsZXZlbFplcm8gJiYgVVpJUCE9bnVsbCkgPyBVWklQIDogcGFrbztcblx0XG5cdGZvcih2YXIgaT0wOyBpPGZ0cnkubGVuZ3RoOyBpKyspIHtcblx0XHRmb3IodmFyIHk9MDsgeTxoOyB5KyspIFVQTkcuZW5jb2RlLl9maWx0ZXJMaW5lKGRhdGEsIGltZywgeSwgYnBsLCBicHAsIGZ0cnlbaV0pO1xuXHRcdC8vdmFyIG5pbWcgPSBuZXcgVWludDhBcnJheShkYXRhLmxlbmd0aCk7XG5cdFx0Ly92YXIgc3ogPSBVWklQLkYuZGVmbGF0ZShkYXRhLCBuaW1nKTsgIGZscy5wdXNoKG5pbWcuc2xpY2UoMCxzeikpO1xuXHRcdC8vdmFyIGRmbCA9IHBha29bXCJkZWZsYXRlXCJdKGRhdGEpLCBkbD1kZmwubGVuZ3RoLTQ7XG5cdFx0Ly92YXIgY3JjID0gKGRmbFtkbCszXTw8MjQpfChkZmxbZGwrMl08PDE2KXwoZGZsW2RsKzFdPDw4KXwoZGZsW2RsKzBdPDwwKTtcblx0XHQvL2NvbnNvbGUubG9nKGNyYywgVVpJUC5hZGxlcihkYXRhLDIsZGF0YS5sZW5ndGgtNikpO1xuXHRcdGZscy5wdXNoKENNUFJbXCJkZWZsYXRlXCJdKGRhdGEsb3B0cykpO1xuXHR9XG5cdHZhciB0aSwgdHNpemU9MWU5O1xuXHRmb3IodmFyIGk9MDsgaTxmbHMubGVuZ3RoOyBpKyspIGlmKGZsc1tpXS5sZW5ndGg8dHNpemUpIHsgIHRpPWk7ICB0c2l6ZT1mbHNbaV0ubGVuZ3RoOyAgfVxuXHRyZXR1cm4gZmxzW3RpXTtcbn1cblVQTkcuZW5jb2RlLl9maWx0ZXJMaW5lID0gZnVuY3Rpb24oZGF0YSwgaW1nLCB5LCBicGwsIGJwcCwgdHlwZSlcbntcblx0dmFyIGkgPSB5KmJwbCwgZGkgPSBpK3ksIHBhZXRoID0gVVBORy5kZWNvZGUuX3BhZXRoXG5cdGRhdGFbZGldPXR5cGU7ICBkaSsrO1xuXG5cdGlmKHR5cGU9PTApIHtcblx0XHRpZihicGw8NTAwKSBmb3IodmFyIHg9MDsgeDxicGw7IHgrKykgZGF0YVtkaSt4XSA9IGltZ1tpK3hdO1xuXHRcdGVsc2UgZGF0YS5zZXQobmV3IFVpbnQ4QXJyYXkoaW1nLmJ1ZmZlcixpLGJwbCksZGkpO1xuXHR9XG5cdGVsc2UgaWYodHlwZT09MSkge1xuXHRcdGZvcih2YXIgeD0gIDA7IHg8YnBwOyB4KyspIGRhdGFbZGkreF0gPSAgaW1nW2kreF07XG5cdFx0Zm9yKHZhciB4PWJwcDsgeDxicGw7IHgrKykgZGF0YVtkaSt4XSA9IChpbWdbaSt4XS1pbWdbaSt4LWJwcF0rMjU2KSYyNTU7XG5cdH1cblx0ZWxzZSBpZih5PT0wKSB7XG5cdFx0Zm9yKHZhciB4PSAgMDsgeDxicHA7IHgrKykgZGF0YVtkaSt4XSA9IGltZ1tpK3hdO1xuXG5cdFx0aWYodHlwZT09MikgZm9yKHZhciB4PWJwcDsgeDxicGw7IHgrKykgZGF0YVtkaSt4XSA9IGltZ1tpK3hdO1xuXHRcdGlmKHR5cGU9PTMpIGZvcih2YXIgeD1icHA7IHg8YnBsOyB4KyspIGRhdGFbZGkreF0gPSAoaW1nW2kreF0gLSAoaW1nW2kreC1icHBdPj4xKSArMjU2KSYyNTU7XG5cdFx0aWYodHlwZT09NCkgZm9yKHZhciB4PWJwcDsgeDxicGw7IHgrKykgZGF0YVtkaSt4XSA9IChpbWdbaSt4XSAtIHBhZXRoKGltZ1tpK3gtYnBwXSwgMCwgMCkgKzI1NikmMjU1O1xuXHR9XG5cdGVsc2Uge1xuXHRcdGlmKHR5cGU9PTIpIHsgZm9yKHZhciB4PSAgMDsgeDxicGw7IHgrKykgZGF0YVtkaSt4XSA9IChpbWdbaSt4XSsyNTYgLSBpbWdbaSt4LWJwbF0pJjI1NTsgIH1cblx0XHRpZih0eXBlPT0zKSB7IGZvcih2YXIgeD0gIDA7IHg8YnBwOyB4KyspIGRhdGFbZGkreF0gPSAoaW1nW2kreF0rMjU2IC0gKGltZ1tpK3gtYnBsXT4+MSkpJjI1NTtcblx0XHRcdFx0XHQgIGZvcih2YXIgeD1icHA7IHg8YnBsOyB4KyspIGRhdGFbZGkreF0gPSAoaW1nW2kreF0rMjU2IC0gKChpbWdbaSt4LWJwbF0raW1nW2kreC1icHBdKT4+MSkpJjI1NTsgIH1cblx0XHRpZih0eXBlPT00KSB7IGZvcih2YXIgeD0gIDA7IHg8YnBwOyB4KyspIGRhdGFbZGkreF0gPSAoaW1nW2kreF0rMjU2IC0gcGFldGgoMCwgaW1nW2kreC1icGxdLCAwKSkmMjU1O1xuXHRcdFx0XHRcdCAgZm9yKHZhciB4PWJwcDsgeDxicGw7IHgrKykgZGF0YVtkaSt4XSA9IChpbWdbaSt4XSsyNTYgLSBwYWV0aChpbWdbaSt4LWJwcF0sIGltZ1tpK3gtYnBsXSwgaW1nW2kreC1icHAtYnBsXSkpJjI1NTsgIH1cblx0fVxufVxuXG5VUE5HLmNyYyA9IHtcblx0dGFibGUgOiAoIGZ1bmN0aW9uKCkge1xuXHQgICB2YXIgdGFiID0gbmV3IFVpbnQzMkFycmF5KDI1Nik7XG5cdCAgIGZvciAodmFyIG49MDsgbjwyNTY7IG4rKykge1xuXHRcdFx0dmFyIGMgPSBuO1xuXHRcdFx0Zm9yICh2YXIgaz0wOyBrPDg7IGsrKykge1xuXHRcdFx0XHRpZiAoYyAmIDEpICBjID0gMHhlZGI4ODMyMCBeIChjID4+PiAxKTtcblx0XHRcdFx0ZWxzZSAgICAgICAgYyA9IGMgPj4+IDE7XG5cdFx0XHR9XG5cdFx0XHR0YWJbbl0gPSBjOyAgfVxuXHRcdHJldHVybiB0YWI7ICB9KSgpLFxuXHR1cGRhdGUgOiBmdW5jdGlvbihjLCBidWYsIG9mZiwgbGVuKSB7XG5cdFx0Zm9yICh2YXIgaT0wOyBpPGxlbjsgaSsrKSAgYyA9IFVQTkcuY3JjLnRhYmxlWyhjIF4gYnVmW29mZitpXSkgJiAweGZmXSBeIChjID4+PiA4KTtcblx0XHRyZXR1cm4gYztcblx0fSxcblx0Y3JjIDogZnVuY3Rpb24oYixvLGwpICB7ICByZXR1cm4gVVBORy5jcmMudXBkYXRlKDB4ZmZmZmZmZmYsYixvLGwpIF4gMHhmZmZmZmZmZjsgIH1cbn1cblxuXG5VUE5HLnF1YW50aXplID0gZnVuY3Rpb24oYWJ1ZiwgcHMpXG57XHRcblx0dmFyIG9pbWcgPSBuZXcgVWludDhBcnJheShhYnVmKSwgbmltZyA9IG9pbWcuc2xpY2UoMCksIG5pbWczMiA9IG5ldyBVaW50MzJBcnJheShuaW1nLmJ1ZmZlcik7XG5cdFxuXHR2YXIgS0QgPSBVUE5HLnF1YW50aXplLmdldEtEdHJlZShuaW1nLCBwcyk7XG5cdHZhciByb290ID0gS0RbMF0sIGxlYWZzID0gS0RbMV07XG5cdFxuXHR2YXIgcGxhbmVEc3QgPSBVUE5HLnF1YW50aXplLnBsYW5lRHN0O1xuXHR2YXIgc2IgPSBvaW1nLCB0YiA9IG5pbWczMiwgbGVuPXNiLmxlbmd0aDtcblx0XHRcblx0dmFyIGluZHMgPSBuZXcgVWludDhBcnJheShvaW1nLmxlbmd0aD4+Mik7XG5cdGZvcih2YXIgaT0wOyBpPGxlbjsgaSs9NCkge1xuXHRcdHZhciByPXNiW2ldKigxLzI1NSksIGc9c2JbaSsxXSooMS8yNTUpLCBiPXNiW2krMl0qKDEvMjU1KSwgYT1zYltpKzNdKigxLzI1NSk7XG5cdFx0XG5cdFx0Ly8gIGV4YWN0LCBidXQgdG9vIHNsb3cgOihcblx0XHR2YXIgbmQgPSBVUE5HLnF1YW50aXplLmdldE5lYXJlc3Qocm9vdCwgciwgZywgYiwgYSk7XG5cdFx0Ly92YXIgbmQgPSByb290O1xuXHRcdC8vd2hpbGUobmQubGVmdCkgbmQgPSAocGxhbmVEc3QobmQuZXN0LHIsZyxiLGEpPD0wKSA/IG5kLmxlZnQgOiBuZC5yaWdodDtcblx0XHRcblx0XHRpbmRzW2k+PjJdID0gbmQuaW5kO1xuXHRcdHRiW2k+PjJdID0gbmQuZXN0LnJnYmE7XG5cdH1cblx0cmV0dXJuIHsgIGFidWY6bmltZy5idWZmZXIsIGluZHM6aW5kcywgcGx0ZTpsZWFmcyAgfTtcbn1cblxuVVBORy5xdWFudGl6ZS5nZXRLRHRyZWUgPSBmdW5jdGlvbihuaW1nLCBwcywgZXJyKSB7XG5cdGlmKGVycj09bnVsbCkgZXJyID0gMC4wMDAxO1xuXHR2YXIgbmltZzMyID0gbmV3IFVpbnQzMkFycmF5KG5pbWcuYnVmZmVyKTtcblx0XG5cdHZhciByb290ID0ge2kwOjAsIGkxOm5pbWcubGVuZ3RoLCBic3Q6bnVsbCwgZXN0Om51bGwsIHRkc3Q6MCwgbGVmdDpudWxsLCByaWdodDpudWxsIH07ICAvLyBiYXNpYyBzdGF0aXN0aWMsIGV4dHJhIHN0YXRpc3RpY1xuXHRyb290LmJzdCA9IFVQTkcucXVhbnRpemUuc3RhdHMoICBuaW1nLHJvb3QuaTAsIHJvb3QuaTEgICk7ICByb290LmVzdCA9IFVQTkcucXVhbnRpemUuZXN0YXRzKCByb290LmJzdCApO1xuXHR2YXIgbGVhZnMgPSBbcm9vdF07XG5cdFxuXHR3aGlsZShsZWFmcy5sZW5ndGg8cHMpXG5cdHtcblx0XHR2YXIgbWF4TCA9IDAsIG1pPTA7XG5cdFx0Zm9yKHZhciBpPTA7IGk8bGVhZnMubGVuZ3RoOyBpKyspIGlmKGxlYWZzW2ldLmVzdC5MID4gbWF4TCkgeyAgbWF4TD1sZWFmc1tpXS5lc3QuTDsgIG1pPWk7ICB9XG5cdFx0aWYobWF4TDxlcnIpIGJyZWFrO1xuXHRcdHZhciBub2RlID0gbGVhZnNbbWldO1xuXHRcdFxuXHRcdHZhciBzMCA9IFVQTkcucXVhbnRpemUuc3BsaXRQaXhlbHMobmltZyxuaW1nMzIsIG5vZGUuaTAsIG5vZGUuaTEsIG5vZGUuZXN0LmUsIG5vZGUuZXN0LmVNcTI1NSk7XG5cdFx0dmFyIHMwd3JvbmcgPSAobm9kZS5pMD49czAgfHwgbm9kZS5pMTw9czApO1xuXHRcdC8vY29uc29sZS5sb2cobWF4TCwgbGVhZnMubGVuZ3RoLCBtaSk7XG5cdFx0aWYoczB3cm9uZykgeyAgbm9kZS5lc3QuTD0wOyAgY29udGludWU7ICB9XG5cdFx0XG5cdFx0XG5cdFx0dmFyIGxuID0ge2kwOm5vZGUuaTAsIGkxOnMwLCBic3Q6bnVsbCwgZXN0Om51bGwsIHRkc3Q6MCwgbGVmdDpudWxsLCByaWdodDpudWxsIH07ICBsbi5ic3QgPSBVUE5HLnF1YW50aXplLnN0YXRzKCBuaW1nLCBsbi5pMCwgbG4uaTEgKTsgIFxuXHRcdGxuLmVzdCA9IFVQTkcucXVhbnRpemUuZXN0YXRzKCBsbi5ic3QgKTtcblx0XHR2YXIgcm4gPSB7aTA6czAsIGkxOm5vZGUuaTEsIGJzdDpudWxsLCBlc3Q6bnVsbCwgdGRzdDowLCBsZWZ0Om51bGwsIHJpZ2h0Om51bGwgfTsgIHJuLmJzdCA9IHtSOltdLCBtOltdLCBOOm5vZGUuYnN0Lk4tbG4uYnN0Lk59O1xuXHRcdGZvcih2YXIgaT0wOyBpPDE2OyBpKyspIHJuLmJzdC5SW2ldID0gbm9kZS5ic3QuUltpXS1sbi5ic3QuUltpXTtcblx0XHRmb3IodmFyIGk9MDsgaTwgNDsgaSsrKSBybi5ic3QubVtpXSA9IG5vZGUuYnN0Lm1baV0tbG4uYnN0Lm1baV07XG5cdFx0cm4uZXN0ID0gVVBORy5xdWFudGl6ZS5lc3RhdHMoIHJuLmJzdCApO1xuXHRcdFxuXHRcdG5vZGUubGVmdCA9IGxuOyAgbm9kZS5yaWdodCA9IHJuO1xuXHRcdGxlYWZzW21pXT1sbjsgIGxlYWZzLnB1c2gocm4pO1xuXHR9XG5cdGxlYWZzLnNvcnQoZnVuY3Rpb24oYSxiKSB7ICByZXR1cm4gYi5ic3QuTi1hLmJzdC5OOyAgfSk7XG5cdGZvcih2YXIgaT0wOyBpPGxlYWZzLmxlbmd0aDsgaSsrKSBsZWFmc1tpXS5pbmQ9aTtcblx0cmV0dXJuIFtyb290LCBsZWFmc107XG59XG5cblVQTkcucXVhbnRpemUuZ2V0TmVhcmVzdCA9IGZ1bmN0aW9uKG5kLCByLGcsYixhKVxue1xuXHRpZihuZC5sZWZ0PT1udWxsKSB7ICBuZC50ZHN0ID0gVVBORy5xdWFudGl6ZS5kaXN0KG5kLmVzdC5xLHIsZyxiLGEpOyAgcmV0dXJuIG5kOyAgfVxuXHR2YXIgcGxhbmVEc3QgPSBVUE5HLnF1YW50aXplLnBsYW5lRHN0KG5kLmVzdCxyLGcsYixhKTtcblx0XG5cdHZhciBub2RlMCA9IG5kLmxlZnQsIG5vZGUxID0gbmQucmlnaHQ7XG5cdGlmKHBsYW5lRHN0PjApIHsgIG5vZGUwPW5kLnJpZ2h0OyAgbm9kZTE9bmQubGVmdDsgIH1cblx0XG5cdHZhciBsbiA9IFVQTkcucXVhbnRpemUuZ2V0TmVhcmVzdChub2RlMCwgcixnLGIsYSk7XG5cdGlmKGxuLnRkc3Q8PXBsYW5lRHN0KnBsYW5lRHN0KSByZXR1cm4gbG47XG5cdHZhciBybiA9IFVQTkcucXVhbnRpemUuZ2V0TmVhcmVzdChub2RlMSwgcixnLGIsYSk7XG5cdHJldHVybiBybi50ZHN0PGxuLnRkc3QgPyBybiA6IGxuO1xufVxuVVBORy5xdWFudGl6ZS5wbGFuZURzdCA9IGZ1bmN0aW9uKGVzdCwgcixnLGIsYSkgeyAgdmFyIGUgPSBlc3QuZTsgIHJldHVybiBlWzBdKnIgKyBlWzFdKmcgKyBlWzJdKmIgKyBlWzNdKmEgLSBlc3QuZU1xOyAgfVxuVVBORy5xdWFudGl6ZS5kaXN0ICAgICA9IGZ1bmN0aW9uKHEsICAgcixnLGIsYSkgeyAgdmFyIGQwPXItcVswXSwgZDE9Zy1xWzFdLCBkMj1iLXFbMl0sIGQzPWEtcVszXTsgIHJldHVybiBkMCpkMCtkMSpkMStkMipkMitkMypkMzsgIH1cblxuVVBORy5xdWFudGl6ZS5zcGxpdFBpeGVscyA9IGZ1bmN0aW9uKG5pbWcsIG5pbWczMiwgaTAsIGkxLCBlLCBlTXEpXG57XG5cdHZhciB2ZWNEb3QgPSBVUE5HLnF1YW50aXplLnZlY0RvdDtcblx0aTEtPTQ7XG5cdHZhciBzaGZzID0gMDtcblx0d2hpbGUoaTA8aTEpXG5cdHtcblx0XHR3aGlsZSh2ZWNEb3QobmltZywgaTAsIGUpPD1lTXEpIGkwKz00O1xuXHRcdHdoaWxlKHZlY0RvdChuaW1nLCBpMSwgZSk+IGVNcSkgaTEtPTQ7XG5cdFx0aWYoaTA+PWkxKSBicmVhaztcblx0XHRcblx0XHR2YXIgdCA9IG5pbWczMltpMD4+Ml07ICBuaW1nMzJbaTA+PjJdID0gbmltZzMyW2kxPj4yXTsgIG5pbWczMltpMT4+Ml09dDtcblx0XHRcblx0XHRpMCs9NDsgIGkxLT00O1xuXHR9XG5cdHdoaWxlKHZlY0RvdChuaW1nLCBpMCwgZSk+ZU1xKSBpMC09NDtcblx0cmV0dXJuIGkwKzQ7XG59XG5VUE5HLnF1YW50aXplLnZlY0RvdCA9IGZ1bmN0aW9uKG5pbWcsIGksIGUpXG57XG5cdHJldHVybiBuaW1nW2ldKmVbMF0gKyBuaW1nW2krMV0qZVsxXSArIG5pbWdbaSsyXSplWzJdICsgbmltZ1tpKzNdKmVbM107XG59XG5VUE5HLnF1YW50aXplLnN0YXRzID0gZnVuY3Rpb24obmltZywgaTAsIGkxKXtcblx0dmFyIFIgPSBbMCwwLDAsMCwgIDAsMCwwLDAsICAwLDAsMCwwLCAgMCwwLDAsMF07XG5cdHZhciBtID0gWzAsMCwwLDBdO1xuXHR2YXIgTiA9IChpMS1pMCk+PjI7XG5cdGZvcih2YXIgaT1pMDsgaTxpMTsgaSs9NClcblx0e1xuXHRcdHZhciByID0gbmltZ1tpXSooMS8yNTUpLCBnID0gbmltZ1tpKzFdKigxLzI1NSksIGIgPSBuaW1nW2krMl0qKDEvMjU1KSwgYSA9IG5pbWdbaSszXSooMS8yNTUpO1xuXHRcdC8vdmFyIHIgPSBuaW1nW2ldLCBnID0gbmltZ1tpKzFdLCBiID0gbmltZ1tpKzJdLCBhID0gbmltZ1tpKzNdO1xuXHRcdG1bMF0rPXI7ICBtWzFdKz1nOyAgbVsyXSs9YjsgIG1bM10rPWE7XG5cdFx0XG5cdFx0UlsgMF0gKz0gcipyOyAgUlsgMV0gKz0gcipnOyAgUlsgMl0gKz0gcipiOyAgUlsgM10gKz0gciphOyAgXG5cdFx0ICAgICAgICAgICAgICAgUlsgNV0gKz0gZypnOyAgUlsgNl0gKz0gZypiOyAgUlsgN10gKz0gZyphOyBcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSWzEwXSArPSBiKmI7ICBSWzExXSArPSBiKmE7ICBcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSWzE1XSArPSBhKmE7ICBcblx0fVxuXHRSWzRdPVJbMV07ICBSWzhdPVJbMl07ICBSWzldPVJbNl07ICBSWzEyXT1SWzNdOyAgUlsxM109Uls3XTsgIFJbMTRdPVJbMTFdO1xuXHRcblx0cmV0dXJuIHtSOlIsIG06bSwgTjpOfTtcbn1cblVQTkcucXVhbnRpemUuZXN0YXRzID0gZnVuY3Rpb24oc3RhdHMpe1xuXHR2YXIgUiA9IHN0YXRzLlIsIG0gPSBzdGF0cy5tLCBOID0gc3RhdHMuTjtcblx0XG5cdC8vIHdoZW4gYWxsIHNhbXBsZXMgYXJlIGVxdWFsLCBidXQgTiBpcyBsYXJnZSAobWlsbGlvbnMpLCB0aGUgUmogY2FuIGJlIG5vbi16ZXJvICggMC4wMDAzLi4uLiAtIHByZWNpc3Npb24gZXJyb3IpXG5cdHZhciBtMCA9IG1bMF0sIG0xID0gbVsxXSwgbTIgPSBtWzJdLCBtMyA9IG1bM10sIGlOID0gKE49PTAgPyAwIDogMS9OKTtcblx0dmFyIFJqID0gW1xuXHRcdFJbIDBdIC0gbTAqbTAqaU4sICBSWyAxXSAtIG0wKm0xKmlOLCAgUlsgMl0gLSBtMCptMippTiwgIFJbIDNdIC0gbTAqbTMqaU4sICBcblx0XHRSWyA0XSAtIG0xKm0wKmlOLCAgUlsgNV0gLSBtMSptMSppTiwgIFJbIDZdIC0gbTEqbTIqaU4sICBSWyA3XSAtIG0xKm0zKmlOLFxuXHRcdFJbIDhdIC0gbTIqbTAqaU4sICBSWyA5XSAtIG0yKm0xKmlOLCAgUlsxMF0gLSBtMiptMippTiwgIFJbMTFdIC0gbTIqbTMqaU4sICBcblx0XHRSWzEyXSAtIG0zKm0wKmlOLCAgUlsxM10gLSBtMyptMSppTiwgIFJbMTRdIC0gbTMqbTIqaU4sICBSWzE1XSAtIG0zKm0zKmlOIFxuXHRdO1xuXHRcblx0dmFyIEEgPSBSaiwgTSA9IFVQTkcuTTQ7XG5cdHZhciBiID0gWzAuNSwwLjUsMC41LDAuNV0sIG1pID0gMCwgdG1pID0gMDtcblx0XG5cdGlmKE4hPTApXG5cdGZvcih2YXIgaT0wOyBpPDEwOyBpKyspIHtcblx0XHRiID0gTS5tdWx0VmVjKEEsIGIpOyAgdG1pID0gTWF0aC5zcXJ0KE0uZG90KGIsYikpOyAgYiA9IE0uc21sKDEvdG1pLCAgYik7XG5cdFx0aWYoTWF0aC5hYnModG1pLW1pKTwxZS05KSBicmVhazsgIG1pID0gdG1pO1xuXHR9XHRcblx0Ly9iID0gWzAsMCwxLDBdOyAgbWk9Tjtcblx0dmFyIHEgPSBbbTAqaU4sIG0xKmlOLCBtMippTiwgbTMqaU5dO1xuXHR2YXIgZU1xMjU1ID0gTS5kb3QoTS5zbWwoMjU1LHEpLGIpO1xuXHRcblx0cmV0dXJuIHsgIENvdjpSaiwgcTpxLCBlOmIsIEw6bWksICBlTXEyNTU6ZU1xMjU1LCBlTXEgOiBNLmRvdChiLHEpLFxuXHRcdFx0XHRyZ2JhOiAoKChNYXRoLnJvdW5kKDI1NSpxWzNdKTw8MjQpIHwgKE1hdGgucm91bmQoMjU1KnFbMl0pPDwxNikgfCAgKE1hdGgucm91bmQoMjU1KnFbMV0pPDw4KSB8IChNYXRoLnJvdW5kKDI1NSpxWzBdKTw8MCkpPj4+MCkgIH07XG59XG5VUE5HLk00ID0ge1xuXHRtdWx0VmVjIDogZnVuY3Rpb24obSx2KSB7XG5cdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRtWyAwXSp2WzBdICsgbVsgMV0qdlsxXSArIG1bIDJdKnZbMl0gKyBtWyAzXSp2WzNdLFxuXHRcdFx0XHRtWyA0XSp2WzBdICsgbVsgNV0qdlsxXSArIG1bIDZdKnZbMl0gKyBtWyA3XSp2WzNdLFxuXHRcdFx0XHRtWyA4XSp2WzBdICsgbVsgOV0qdlsxXSArIG1bMTBdKnZbMl0gKyBtWzExXSp2WzNdLFxuXHRcdFx0XHRtWzEyXSp2WzBdICsgbVsxM10qdlsxXSArIG1bMTRdKnZbMl0gKyBtWzE1XSp2WzNdXG5cdFx0XHRdO1xuXHR9LFxuXHRkb3QgOiBmdW5jdGlvbih4LHkpIHsgIHJldHVybiAgeFswXSp5WzBdK3hbMV0qeVsxXSt4WzJdKnlbMl0reFszXSp5WzNdOyAgfSxcblx0c21sIDogZnVuY3Rpb24oYSx5KSB7ICByZXR1cm4gW2EqeVswXSxhKnlbMV0sYSp5WzJdLGEqeVszXV07ICB9XG59XG5cblVQTkcuZW5jb2RlLmNvbmNhdFJHQkEgPSBmdW5jdGlvbihidWZzKSB7XG5cdHZhciB0bGVuID0gMDtcblx0Zm9yKHZhciBpPTA7IGk8YnVmcy5sZW5ndGg7IGkrKykgdGxlbiArPSBidWZzW2ldLmJ5dGVMZW5ndGg7XG5cdHZhciBuaW1nID0gbmV3IFVpbnQ4QXJyYXkodGxlbiksIG5vZmY9MDtcblx0Zm9yKHZhciBpPTA7IGk8YnVmcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpbWcgPSBuZXcgVWludDhBcnJheShidWZzW2ldKSwgaWwgPSBpbWcubGVuZ3RoO1xuXHRcdGZvcih2YXIgaj0wOyBqPGlsOyBqKz00KSB7ICBcblx0XHRcdHZhciByPWltZ1tqXSwgZz1pbWdbaisxXSwgYj1pbWdbaisyXSwgYSA9IGltZ1tqKzNdO1xuXHRcdFx0aWYoYT09MCkgcj1nPWI9MDtcblx0XHRcdG5pbWdbbm9mZitqXT1yOyAgbmltZ1tub2ZmK2orMV09ZzsgIG5pbWdbbm9mZitqKzJdPWI7ICBuaW1nW25vZmYraiszXT1hOyAgfVxuXHRcdG5vZmYgKz0gaWw7XG5cdH1cblx0cmV0dXJuIG5pbWcuYnVmZmVyO1xufVxuXG5leHBvcnQgZGVmYXVsdCBVUE5HO1xuXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@pdf-lib+upng@1.0.1/node_modules/@pdf-lib/upng/UPNG.js\n");

/***/ })

};
;